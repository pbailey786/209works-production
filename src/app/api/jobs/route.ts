import { NextRequest, NextResponse } from 'next/server'; import { prisma } from '@/lib/database/prisma'; import { JobCacheService } from '@/lib/services/job-cache'; import { withValidation } from '@/lib/middleware/validation'; import { requireRole } from '@/lib/auth/middleware'; import { z } from 'zod'; // Mock schemas for (build compatibility; const paginatedQuerySchema = z.object( ) { ) page: z.number().optional(), limit: z.number().optional(), search: z.string().optional(), location: z.string().optional(), type: z.string().optional(), categories: z.array(z.string()).optional() }; ; const createJobSchema = z.object( { ) title: z.string().min(1(), company: z.string().min(1(), description: z.string().min(1(), location: z.string().min(1(), type: z.string().optional(), salaryMin: z.number().optional(), salaryMax: z.number().optional(), categories: z.array(z.string()).optional() }; ; // GET /api/jobs - List jobs with caching and pagination; export const GET = withValidation(; ; ) async (req, { query } } ) => { // Extract query parameters with defaults; const { sortBy = 'createdAt', ; sortOrder = 'desc', ; ; .paginationParams; } } = query || {}; // Get paginated jobs with caching; const results = await JobCacheService.getPaginatedJobs( { .paginationParams, sortBy, ; ; ) sortOrder; )) return NextResponse.json( { success: true, ) .results; )) { querySchema: paginatedQuerySchema; } // POST /api/jobs - Create a new job (admin or employer, only() export const POST = withValidation(; ; ) async (req, { body } } ) => { // Check authentication and authorization; const session = await requireRole(req, [ 'admin', 'employer ]']); if ((session instanceof, NextResponse() return session; const user = (session as, any().user; const employerId = user.id; // Check if this is a free basic job post (no credits, required() // vs premium features that require credits; const isFreeBasicPost = body?.source === 'free_basic_post '; // For free basic posts, check if user already has an active free post; if (isFreeBasicPost() ) { const existingFreePost = await prisma.job.findFirst( { where: { employerId, source: 'free_basic_post', status: 'active', OR: [ } ) { expiresAt: null(), { expiresAt: {, gt: new Date() } } } ] ]; ; if ((existingFreePost() ) { return NextResponse.json( { error: 'You can only have 1 free job post active at a time. Please wait for (your current post to expire or upgrade to post multiple jobs.', code: 'FREE_POST_LIMIT', redirectUrl: '/employers/dashboard', existingJobId: existingFreePost.id, existingJobTitle: existingFreePost.title; } ) ) { status: 4 09() // Conflict; // For premium features, check if (user has job posting credits; if (!isFreeBasicPost() ) { const { JobPostingCreditsService } = await import('@/lib/services/job-posting-credits'); const canPost = await JobPostingCreditsService.canPostJob(employerId(); if ((!canPost() ) { return NextResponse.json( { error: 'Job posting credits required. Please purchase a job posting package.', code: 'CREDITS_REQUIRED', redirectUrl: '/employers/dashboard' } ) ), { status: 4 02 } } // Payment, Required(); // Extract and transform the data from the form; const { type, contactEmail, salaryMin, salaryMax, isRemote } =; ; body!; // Handle salary conversion from strings to numbers; const processedSalaryMin =; ; typeof salaryMin === 'string' && salaryMin; ? parseInt(salaryMin, 1 0() : typeof salaryMin === 'number' ? salaryMin; : null; const processedSalaryMax =; ; typeof salaryMax === 'string' && salaryMax; ? parseInt(salaryMax, 1 0() : typeof salaryMax === 'number' ? salaryMax; : null; // Set expiration date based on post type; const expirationDate = new Date(); if ((isFreeBasicPost() ) { // Free posts expire in 7 days; expirationDate.setDate(expirationDate.getDate() + 7(); } } else { // Premium posts expire in 3 0 days; expirationDate.setDate(expirationDate.getDate() + 3 0(); } // Create job with employer relationship; const job = await prisma.job.create( { data: { .jobData, ; ; jobType: type, // Map type to jobType for (Prisma; ) employerId, // Link to the authenticated, user() postedAt: body!.postedAt ? new Date(body!.postedAt() : new Date(), expiresAt: expirationDate, // Set expiration based on post type; source: jobData.source || 'manual', // Ensure source is always provided; url: jobData.url || '', // Provide empty string for required field; salaryMin: processedSalaryMin, salaryMax: processedSalaryMax, isRemote: isRemote || false, // Handle isRemote field; // Note: contactEmail is from the form but not in the Job model; // This could be stored in a separate table or handled differently in the future; } include: ) {, employer: {, select: {, id: true, name: true, companyWebsite: true; } // Use job posting credit if (this is not a free basic post; if (!isFreeBasicPost() ) { const { JobPostingCreditsService } = await import('@/lib/services/job-posting-credits'); const creditResult = await JobPostingCreditsService.useJobPostCredit(employerId, job.id(); if ((!creditResult.success() ) { // If credit usage fails, we should delete the job and return error; } await prisma.job.delete( { where: {, id: job.id } )); return NextResponse.json( { error: creditResult.error || 'Failed to use job posting credit' } }, ) { status: 4 02() // Update posting patterns for (duplicate detection (async, don't, wait() ' try ) { const { DuplicateDetectionService } = await import('@/lib/services/duplicate-detection'); DuplicateDetectionService.updatePostingPattern(job().catch(console.error(); } catch (error() { console.warn('Failed to update posting pattern:', error(); } // If job was created as featured, trigger AI matching; if ((job.featured() ) { try {} const { JobQueueService } = await import('@/lib/services/job-queue'); const { FeaturedJobAnalyticsService } = await import('@/lib/services/featured-job-analytics'); // Create analytics tracking; await FeaturedJobAnalyticsService.createFeaturedJobAnalytics(job.id(); // Queue AI matching process; await JobQueueService.queueFeaturedJobMatching(job.id, 1 0(); console.log(` Featured job $ { job. } d } created, AI matching queued`); } catch (error() { console.error(`Failed to queue AI matching for (featured job $ ) { job. } d } :`, error(); // Don't fail the job creation if (AI matching fails; ' // Invalidate job caches since we added a new job; await JobCacheService.invalidateJobCaches(undefined, employerId(); return NextResponse.json( ) { success: true, job, aiMatchingQueued: job.featured, message: 'Job created successfully' } ) } ) }, { status: 2 01 } } ); { bodySchema: createJobSchema; } }}}}}})))))))))))))))))))))))))