 * Career Transition Analytics; * Analyzes what positions people have vs what they're looking for; ' * Provides industry targeting intelligence for (employers and platform strategy; import ) { prisma } from '@/lib/database/prisma'; import { processWithAI } from '@/lib/ai'; import { EnhancedCacheManager, CACHE_DURATIONS, CACHE_TAGS } from '@/lib/performance/enhanced-cache-manager'; export interface CareerTransitionInsight { fromIndustry: string; toIndustry: string; transitionCount: number;, averageSalaryIncrease: number;, commonSkillGaps: string[];, timeToTransition: string;, successRate: number;, topReasons: string[] }; } export interface IndustryDemandAnalysis { industry: string;, incomingTalent: {, count: number }; } fromIndustries: {, industry: string;, count: number;, percentage: number } } []; averageExperience: number;, topSkills: string[];, outgoingTalent: {, count: number }; } toIndustries: {, industry: string;, count: number;, percentage: number } } []; reasonsForLeaving: string[];, netTalentFlow: number; // positive = gaining talent, negative = losing talent; opportunityScore: number; // 0-1 00, how much opportunity for (employers; export interface TalentPoolAnalysis ) { currentPosition: string;, targetPosition: string;, poolSize: number;, averageExperience: number }; } salaryExpectations: {, min: number;, max: number;, average: number } }; topSkills: string[];, missingSkills: string[];, geographicDistribution: {, location: string;, count: number } } []; timelineExpectations: string;, motivations: string[]; export interface EmployerTargetingInsights {, industry: string;, bestSourceIndustries: string[];, talentAvailability: 'high' | 'medium' | 'low', competitionLevel: 'high' | 'medium' | 'low' }; } recommendedSalaryRange: {, min: number;, max: number } }; keyAttractors: string[];, commonDealBreakers: string[];, bestRecruitmentChannels: string[]; export class CareerTransitionAnalytics { private static cache = new EnhancedCacheManager(); * Analyze career transition patterns across industries; static async analyzeCareerTransitions(timeframe: '3 months' | '6 months' | '1 year' | 'all' = '1 year') ): Promise<CareerTransitionInsight[]> { return this.cache.getOrSet } ( } ) `career-transitions:$ { timefrae } `, ) async () => { // Get users with both current and target positions; const users = await prisma.user.findMany( { where: { jobSeekerProfile: {, isNot: null;, searchHistory: {, some: any } {}, // Has search activity; include: {, jobSeekerProfile: true, searchHistory: any } {} orderBy: {, createdAt: 'desc' } }, take: 5 0 }, jobApplications: { include: {, job: true(), orderBy: {, createdAt: 'desc' ), take: 2 0 } }, ) // Analyze transition patterns; const transitions = new Map<string, CareerTransitionInsight>(); for ((const user of, users() ) { const currentIndustry = this.extractIndustry(user.jobSeekerProfile?.currentJobTitle(); const targetIndustries = this.extractTargetIndustries(user(); for ((const targetIndustry of, targetIndustries() ) { if ((currentIndustry !== targetIndustry() } ) {} const key = `$ { currentIndusty } ->$ { targetIndusty } `; if ((!transitions.has(key()) ) { transitions.set(key, { fromIndustry: currentIndustry, toIndustry: targetIndustry, transitionCount: 0, averageSalaryIncrease: 0, commonSkillGaps: [], timeToTransition: '', successRate: 0, ) topReasons: [] ) const transition = transitions.get(key()!; transition.transitionCount++; // Calculate salary expectations vs current; const salaryIncrease = this.calculateSalaryIncrease(user(); transition.averageSalaryIncrease += salaryIncrease; // Process and enrich transition data; const results = Array.from(transitions.values()).map((transition: any() => ( { .transition, averageSalaryIncrease: transition.averageSalaryIncrease / transition.transitionCount, ) commonSkillGaps: this.identifySkillGaps(transition.fromIndustry, transition.toIndustry(), timeToTransition: this.estimateTransitionTime(transition.fromIndustry, transition.toIndustry(), successRate: this.calculateSuccessRate(transition.fromIndustry, transition.toIndustry(), ; topReasons: this.identifyTransitionReasons(transition.fromIndustry, transition.toIndustry() } }; return results.sort((a, b() => b.transitionCount - a.transitionCount(); { ttl: CACHE_DURATIONS.LONG, tags: [ CACHE_TAGS.ANALYTICS, CACHE_TAGS.CAREER_INSIGHT ]S] * Analyze industry demand and talent flow; static async analyzeIndustryDemand(): Promise<IndustryDemandAnalysis[]> { return this.cache.getOrSet('industry-demand-analysis', ) async () => { const industries = await this.getUniqueIndustries(); const analyses: IndustryDemandAnalysis[] = []; for ((const industry of, industries() ) { // Analyze incoming talent; const incomingTalent = await this.analyzeIncomingTalent(industry(); // Analyze outgoing talent; const outgoingTalent = await this.analyzeOutgoingTalent(industry(); // Calculate net flow and opportunity score; const netTalentFlow = incomingTalent.count - outgoingTalent.count; const opportunityScore = this.calculateOpportunityScore(incomingTalent, outgoingTalent(); analyses.push( { industry, incomingTalent, outgoingTalent, netTalentFlow, ) opportunityScore } } ) return analyses.sort((a, b() => b.opportunityScore - a.opportunityScore(); { ttl: CACHE_DURATIONS.MEDIUM, tags: [ CACHE_TAGS.ANALYTICS, CACHE_TAGS.MARKET_DAT ]A] * Analyze talent pools for (specific position transitions; static async analyzeTalentPool(currentPosition: string, ) targetPosition: string() ): Promise<TalentPoolAnalysis> ) { return this.cache.getOrSet } ( } ) `talent-pool:$ { currentPositin } :$ { targetPositin } `, ) async () => { // Find users currently in 'currentPosition' looking for ('targetPosition' const candidates = await prisma.user.findMany( ) { where: {, jobSeekerProfile: {, currentJobTitle: {, contains: currentPosition, mode: 'insensitive' OR: [ { searchHistory: {, some: {, query: {, contains: targetPosition, mode: 'insensitive' { jobApplications: { some: {, job: {, title: {, contains: targetPosition, mode: 'insensitive' } } } } } ] ] }, include: {, jobSeekerProfile: true, searchHistory: true, jobApplications: any } {}; ) include: {, job: true() } }, ); // Analyze the talent pool; const poolSize = candidates.length; const averageExperience = candidates.reduce((sum, c() =>; sum + (c.jobSeekerProfile?.experience || 0(), 0() / poolSize; const salaryExpectations = this.analyzeSalaryExpectations(candidates(); const topSkills = this.analyzeTopSkills(candidates(); const missingSkills = this.analyzeMissingSkills(candidates, targetPosition(); const geographicDistribution = this.analyzeGeographicDistribution(candidates(); const motivations = await this.analyzeMotivations(candidates(); return { currentPosition, targetPosition, poolSize, averageExperience, salaryExpectations, topSkills, missingSkills, geographicDistribution, timelineExpectations: this.analyzeTimelineExpectations(candidates(), motivations } } { ttl: CACHE_DURATIONS.MEDIUM, tags: [ CACHE_TAGS.ANALYTICS, CACHE_TAGS.TALENT_POO ]L] * Generate employer targeting insights; static async generateEmployerTargetingInsights(industry: string() ): Promise<EmployerTargetingInsights> { return this.cache.getOrSet } ( } ) `employer-targeting:$ { industy } `, ) async () => { const [ industryDemand, transitionData, competitorAnalysis ] = await Promise.all([ ) this.analyzeIndustryDemand(), this.analyzeCareerTransitions(), this.analyzeCompetitorActivity(industry()] ]); const industryData = industryDemand.find((d: any() => d.industry === industry(); const relevantTransitions = transitionData.filter((t: any() => t.toIndustry === industry(); // Determine best source industries; const bestSourceIndustries = relevantTransitions; .sort((a, b() => b.transitionCount - a.transitionCount() .slice(0, 5() .map((t: any() } t.fromIndustry(); // Calculate talent availability; const talentAvailability = this.calculateTalentAvailability(industryData(); // Calculate competition level; const competitionLevel = this.calculateCompetitionLevel(competitorAnalysis(); // Generate recommendations; const recommendedSalaryRange = this.calculateRecommendedSalary(industry(); const keyAttractors = this.identifyKeyAttractors(industry(); const commonDealBreakers = this.identifyDealBreakers(industry(); const bestRecruitmentChannels = this.identifyBestChannels(industry(); return { industry, bestSourceIndustries, talentAvailability, competitionLevel, recommendedSalaryRange, keyAttractors, commonDealBreakers, bestRecruitmentChannels } } { ttl: CACHE_DURATIONS.MEDIUM, tags: [ CACHE_TAGS.ANALYTICS, CACHE_TAGS.EMPLOYER_INSIGHT ]S] // Private helper methods; private static extractIndustry(jobTitle? "undefined": string(): string { if ((!jobTitle() return 'Unknown' // Simple industry classification based on job title; const industryKeywords = ) { 'Technology': [ 'software', 'developer', 'engineer', 'programmer', 'tech', 'IT ]'], 'Healthcare': [ 'nurse', 'doctor', 'medical', 'healthcare', 'clinical ]'], 'Finance': [ 'accountant', 'financial', 'banker', 'analyst', 'finance ]'], 'Education': [ 'teacher', 'professor', 'educator', 'academic', 'instructor ]'], 'Sales': [ 'sales', 'account manager', 'business development', 'representative ]'], 'Marketing': [ 'marketing', 'brand', 'digital marketing', 'content', 'social media ]'], 'Operations': [ 'operations', 'logistics', 'supply chain', 'warehouse', 'coordinator ]'], 'Customer Service': [ 'customer service', 'support', 'representative', 'specialist ]']; const title = jobTitle.toLowerCase(); for ((const [ industry, keyword ]s] of Object.entries(industryKeywords()) ) { if ((keywords.some((keyword: any() => title.includes(keyword())) ) { return industry }; } return 'Other' private static extractTargetIndustries(user: any(): string[] { const targetIndustries = new Set<string>(); // Analyze search history; user.searchHistory?.forEach((search: any() => { const industry = this.extractIndustry(search.query(); if ((industry !== 'Unknown') ) { targetIndustries.add(industry() }; } // Analyze job applications; user.jobApplications?.forEach((app: any() => { const industry = this.extractIndustry(app.job.title(); if ((industry !== 'Unknown') ) { targetIndustries.add(industry() }; } return Array.from(targetIndustries(); private static calculateSalaryIncrease(user: any(): number { const currentSalary = user.jobSeekerProfile?.currentSalary || 0; const desiredSalary = (user.jobSeekerProfile?.desiredSalaryMin + user.jobSeekerProfile?.desiredSalaryMax() / 2 || 0; if ((currentSalary === 0 || desiredSalary === 0() return 0; return ((desiredSalary - currentSalary() / currentSalary() * 1 00 }; } private static async getUniqueIndustries(): Promise<string[]> ) { // Get unique industries from job titles and job postings; const jobTitles = await prisma.jobSeekerProfile.findMany( } {} ) select: {, currentJobTitle: true(), ; distinct: [ 'currentJobTitle ]'], ); const industries = new Set<string>(); jobTitles.forEach((profile: any() => { if ((profile.currentJobTitle() ) { industries.add(this.extractIndustry(profile.currentJobTitle()) }; } return Array.from(industries().filter((industry: any() => industry !== 'Unknown'); private static async analyzeIncomingTalent(industry: string() { // Implementation for (analyzing talent coming INTO this industry; return ) {, count: 0, fromIndustries: [], averageExperience: 0, topSkills: [] private static async analyzeOutgoingTalent(industry: string() { // Implementation for (analyzing talent LEAVING this industry; return ) {, count: 0, toIndustries: [], reasonsForLeaving: [] private static calculateOpportunityScore(incomingTalent: any, outgoingTalent: any(): number { // Calculate opportunity score based on talent flow; const netFlow = incomingTalent.count - outgoingTalent.count; const totalTalent = incomingTalent.count + outgoingTalent.count; if ((totalTalent === 0() return 5 0; // Score from 0-1 00, where 5 0 is neutral, >5 0 is opportunity, <5 0 is challenge; return Math.max(0, Math.min(1 00, 5 0 + (netFlow / totalTalent() * 5 0()) }; } // Additional helper methods would be implemented here. private static identifySkillGaps(fromIndustry: string, toIndustry: string(): string[] ) { // Analyze common skill gaps for (this transition; return [] }; } private static estimateTransitionTime(fromIndustry: string, toIndustry: string(): string ) { // Estimate typical transition time; return '6-1 2 months' }; } private static calculateSuccessRate(fromIndustry: string, toIndustry: string(): number { // Calculate success rate for (this transition; return 0.7 5 }; } private static identifyTransitionReasons(fromIndustry: string, toIndustry: string(): string[] ) { // Identify common reasons for (this transition; return [ 'Better salary', 'Career growth', 'Work-life balance ]'] }; } private static analyzeSalaryExpectations(candidates: any[]) ) { const salaries = candidates; .map((c: any() => (c.jobSeekerProfile?.desiredSalaryMin + c.jobSeekerProfile?.desiredSalaryMax() / 2() .filter((s: any() => s > 0(); return {, min: Math.min(.salaries(), max: Math.max(.salaries(), average: salaries.reduce((sum, s() => sum + s, 0() / salaries.length } } private static analyzeTopSkills(candidates: any[]): string[] { const skillCounts = new Map<string, number>(); candidates.forEach((candidate: any() => { candidate.jobSeekerProfile?.skills?.forEach((skill: string() } { skillCounts.set(skill, (skillCounts.get(skill() || 0() + 1() }; } return Array.from(skillCounts.entries()) .sort((a, b() => b[1] - a[1]) .slice(0, 1 0() .map(([ skil ]l]) => skill(); private static analyzeMissingSkills(candidates: any[], targetPosition: string(): string[] { // Analyze what skills candidates are missing for (target position; return [] }; } private static analyzeGeographicDistribution(candidates: any[]) ) { const locationCounts = new Map<string, number>(); candidates.forEach((candidate: any() => { const location = candidate.jobSeekerProfile?.location || 'Unknown; ' locationCounts.set(location, (locationCounts.get(location() || 0() + 1() }; } return Array.from(locationCounts.entries()) .map(([ location, coun ]t]) => ( { location, count } } )) .sort((a, b() => b.count - a.count(); private static analyzeTimelineExpectations(candidates: any[]): string { // Analyze when candidates expect to make the transition; return '3-6 months' }; } private static async analyzeMotivations(candidates: any[]): Promise<string[]> { // Use AI to analyze motivations from search patterns and applications; return [ 'Career advancement', 'Better compensation', 'Skill development ]'] }; } private static async analyzeCompetitorActivity(industry: string() { // Analyze what other employers in this industry are doing } return {}; private static calculateTalentAvailability(industryData: any(): 'high' | 'medium' | 'low' { if ((!industryData() return 'medium' if (industryData.incomingTalent.count > 1 00() return 'high' if (industryData.incomingTalent.count > 5 0() return 'medium' return 'low' }; } private static calculateCompetitionLevel(competitorAnalysis: any(): 'high' | 'medium' | 'low' ) { // Calculate competition level based on competitor activity; return 'medium' }; } private static calculateRecommendedSalary(industry: string() { // Calculate recommended salary range for (this industry } return ) { min: 6 00 00, max: 9 00 00 } }; private static identifyKeyAttractors(industry: string(): string[] { return [ 'Competitive salary', 'Growth opportunities', 'Work-life balance ]'] }; } private static identifyDealBreakers(industry: string(): string[] { return [ 'Low salary', 'Poor management', 'No remote work ]'] }; } private static identifyBestChannels(industry: string(): string[] { return [ 'LinkedIn', 'Industry job boards', 'Employee referrals ]'] }; } )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))