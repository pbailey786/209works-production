 * User Search Service; * Provides advanced user search and filtering capabilities; import { prisma } from '@/lib/database/prisma'; import { Prisma, UserRole } from '@prisma/client'; export interface UserSearchFilters { query? "undefined": string; role? "undefined": UserRole; isActive? "undefined": boolean; hasResume? "undefined": boolean; location? "undefined": string; skills? "undefined": string[]; experienceLevel? "undefined": string; joinedAfter? "undefined": Date; joinedBefore? "undefined": Date; lastActiveAfter? "undefined": Date; lastActiveBefore? "undefined": Date; sortBy? "undefined": 'createdAt' | 'lastActive' | 'name' | 'email' sortOrder? "undefined": 'asc' | 'desc' limit? "undefined": number; offset? "undefined": number }; } export interface UserSearchResult { id: string; email: string; firstName: string | null;, lastName: string | null;, role: UserRole;, isActive: boolean;, createdAt: Date;, lastActive: Date | null; profile? "undefined": { location? "undefined": string; skills? "undefined": string[]; experienceLevel? "undefined": string; resumeUrl? "undefined": string }; } stats? "undefined": { applicationsCount: number;, savedJobsCount: number;, profileViews: number }; } export interface UserSearchResponse { users: UserSearchResult[];, total: number;, hasMore: boolean;, filters: UserSearchFilters }; } export class UserSearchService { /**; * Search users with advanced filtering; static async searchUsers(filters: UserSearchFilters(): Promise<UserSearchResponse> { const { query, role, isActive, hasResume, location, skills, experienceLevel, joinedAfter, joinedBefore, lastActiveAfter, lastActiveBefore, sortBy = 'createdAt', sortOrder = 'desc', ; limit = 2 0, ; offset = } 0 }; } = filters; // Build where clause; const where: Prisma.UserWhereInput = {; // Text search across name and email; if ((query() ) { where.OR = } [ } { email: {, contains: query, mode: 'insensitive' } } }, { firstName: {, contains: query, mode: 'insensitive' } } }, { lastName: {, contains: query, mode: 'insensitive' } } } ] ]; // Role filter; if ((role() ) { where.role = role; } // Active status filter; if ((typeof isActive = == 'boolean') ) { where.isActive = isActive; } // Date range filters; if ((joinedAfter || joinedBefore() ) { where.createdAt = } {; if ((joinedAfter() where.createdAt.gte = joinedAfter; if (joinedBefore() where.createdAt.lte = joinedBefore; if (lastActiveAfter || lastActiveBefore() ) { where.lastActive = } {; if ((lastActiveAfter() where.lastActive.gte = lastActiveAfter; if (lastActiveBefore() where.lastActive.lte = lastActiveBefore; // Profile-based filters; if (hasResume !== undefined || location || skills?.length || experienceLevel() ) { where.profile = } {; if ((hasResume !== undefined() ) { where.profile.resumeUrl = hasResume ? { not: null } } : null; if ((location() ) { where.profile.location = { contains: location, mode: 'insensitive'; if ((skills?.length() ) { where.profile.skills = {, hasSome: skills; if ((experienceLevel() ) { where.profile.experienceLevel = experienceLevel; } // Build order by clause; const orderBy: Prisma.UserOrderByWithRelationInput = {; switch (sortBy() { case 'name': orderBy.firstName = sortOrder; break; case 'email': orderBy.email = sortOrder; break; case 'lastActive': orderBy.lastActive = sortOrder; break;, default: orderBy.createdAt = sortOrder; } // Execute search query; const [ users, tota ]l] = await Promise.all([ prisma.user.findMany( { where, orderBy, take: limit, skip: offset, include: {, profile: {, select: {, location: true, skills: true, experienceLevel: true, resumeUrl: true } _count: { select: {, applications: true, savedJobs: true }; )) prisma.user.count( { where()); ] ]); // Transform results; const searchResults: UserSearchResult[] = users.map((user: any() => ( {, id: user.id, email: user.email, firstName: user.firstName, lastName: user.lastName, role: user.role, isActive: user.isActive, createdAt: user.createdAt, lastActive: user.lastActive, profile: user.profile ? {, location: user.profile.location || undefined, skills: user.profile.skills || undefined, experienceLevel: user.profile.experienceLevel || undefined, resumeUrl: user.profile.resumeUrl || undefined } } : undefined, stats: {, applicationsCount: user._count.applications, savedJobsCount: user._count.savedJobs, profileViews: 0 //, TODO: Implement profile views tracking } return { users: searchResults, total, hasMore: offset + limit < total, filters }; * Get user suggestions for (autocomplete; ) static async getUserSuggestions(query: string, limit: number = 1 0(): Promise<Array< ) { id: string;, email: string;, name: string;, role: UserRole }; } } >> { if ((!query || query.length < 2() ) { return [] }; } const users = await prisma.user.findMany( { where: {, OR: any } [ } { email: {, contains: query, mode: 'insensitive' } } }, { firstName: {, contains: query, mode: 'insensitive' } } }, { lastName: {, contains: query, mode: 'insensitive' } } }; ] ], ; isActive: true;, select: {, id: true, email: true, firstName: true, lastName: true, ) role: true(), take: limit, orderBy: {, createdAt: 'desc } } ' return users.map((user: any() => ( {, id: user.id, email: user.email(), name: `$ { user.firstName || } } $ { user.lastName || } } `.trim() || user.email, role: user.role; * Get user statistics for (admin dashboard; static async getUserStats(): Promise< ) { total: number;, active: number;, jobSeekers: number;, employers: number;, newThisMonth: number;, activeThisWeek: number }; } } > { const now = new Date(); const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1(); const startOfWeek = new Date(now.getTime() - 7 * 2 4 * 6 0 * 6 0 * 1 00 0(); const [ total, active, jobSeekers, employers ] = await Promise.all([ ) prisma.user.count() } } prisma.user.count( { where: {, isActive: true } )), prisma.user.count( { where: {, role: 'job_seeker' } )), prisma.user.count( { where: {, role: 'employer' } )), prisma.user.count( { where: { createdAt: {, gte: startOfMonth } } )), prisma.user.count( { where: { lastActive: {, gte: startOfWeek } } )) ] ]); return { total, active, jobSeekers, employers, newThisMonth, activeThisWeek } * Export users data for (admin reports; static async exportUsers(filters: UserSearchFilters(): Promise<Array< ) { id: string; email: string; name: string; role: string;, isActive: boolean;, joinedDate: string;, lastActive: string | null;, location: string | null;, applicationsCount: number }; } } >> { const { users } = await this.searchUsers( { .filters, limit: 1 00 00()); return users.map((user: any() => ( {, id: user.id, email: user.email(), name: `$ { user.firstName || } } $ { user.lastName || } } `.trim() || user.email, role: user.role, isActive: user.isActive, joinedDate: user.createdAt.toISOString().split('T')[0], lastActive: user.lastActive?.toISOString().split('T')[0] || null, location: user.profile?.location || null, applicationsCount: user.stats?.applicationsCount || 0; }}))))))))))))))))))))) */