 * Advanced Analytics Service for (2 09 Works; * Provides comprehensive analytics, reporting, and business intelligence; import ) { prisma } from '@/lib/database/prisma'; import { cache } from 'react'; export interface AnalyticsTimeRange { startDate: Date;, endDate: Date;, period: 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year' }; } export interface UserBehaviorMetrics { totalUsers: number; activeUsers: number; newUsers: number; returningUsers: number; averageSessionDuration: number;, bounceRate: number;, pageViews: number;, uniquePageViews: number;, conversionRate: number;, userRetentionRate: number }; } export interface JobPerformanceMetrics { totalJobs: number; activeJobs: number; jobsPostedToday: number; averageTimeToFill: number; applicationRate: number; viewToApplicationRate: number; topPerformingJobs: Array< { id: string;, title: string;, company: string;, views: number;, applications: number;, conversionRate: number }; } } >; jobsByCategory: Array< {, category: string;, count: number;, percentage: number }; } } >; jobsByLocation: Array< {, location: string;, count: number;, percentage: number }; } } >; export interface BusinessIntelligence { revenue: {; total: number;, recurring: number;, oneTime: number;, growth: number;, arpu: number; // Average Revenue Per User;, ltv: number; // Customer Lifetime Value } employers: { total: number; active: number; new: number; churnRate: number; averageJobsPerEmployer: number;, topSpenders: Array< {, id: string;, companyName: string;, totalSpent: number;, jobsPosted: number }; } } >; jobSeekers: { total: number; active: number; new: number; averageApplicationsPerUser: number;, profileCompletionRate: number;, topSkills: Array< {, skill: string;, count: number;, percentage: number }; } } >; export interface RegionalAnalytics { regions: Array< {; region: string; domain: string;, users: number;, jobs: number;, applications: number;, revenue: number;, growth: number }; } } >; crossRegionalActivity: { usersViewingMultipleRegions: number;, crossRegionalApplications: number;, mostPopularRegionPairs: Array< {, from: string;, to: string;, count: number }; } } >; export interface AIAnalytics { jobsGPT: {; totalSessions: number; totalQuestions: number; averageResponseTime: number;, successRate: number;, topIntents: Array< {, intent: string;, count: number;, percentage: number }; } } >; userSatisfactionScore: number; shouldIApply: { totalUsage: number; averageMatchScore: number;, applicationConversionRate: number;, topRecommendationReasons: Array< {, reason: string;, count: number }; } } >; resumeAnalysis: { totalAnalyses: number;, averageScore: number;, topImprovementSuggestions: Array< {, suggestion: string;, frequency: number }; } } >; export class AdvancedAnalyticsService { /**; * Get comprehensive user behavior metrics; static getUserBehaviorMetrics = cache(async ( timeRange: AnalyticsTimeRange, )) region? "undefined": string() ): Promise<UserBehaviorMetrics> => } {} const { startDate, endDate } = timeRange; // Build region filter; const regionFilter = region ? { region } } : {; const [ totalUsers, activeUsers, newUsers, sessionData ] = await Promise.all([ // Total users; prisma.user.count( { where: any } {} )) createdAt: {, lte: endDate(), .regionFilter; // Active users (users with activity in time, range() prisma.user.count( { where: {, OR: any } [ } { lastLoginAt: {, gte: startDate, lte: endDate } } }, ) { updatedAt: {, gte: startDate, lte: endDate } ) ] ], .regionFilter; // New users in time range; prisma.user.count( { where: any } {} ) createdAt: {, gte: startDate, lte: endDate(), .regionFilter; // Session data from analytics; prisma.$queryRaw<Array< { avg_duration: number;, total_sessions: number } } >>`` SELECT; AVG(EXTRACT(EPOCH FROM (updatedAt - createdAt())) as avg_duration, COUNT(*) as total_sessions; FROM ChatAnalytics; WHERE createdAt >= $ { startDae } AND createdAt <= $ { endDae } `, ` // Page view data (mock for (now - would come from analytics, service() Promise.resolve( ) { pageViews: 0, uniquePageViews: 0, bounceRate: 0()), // Conversion data (applications vs job, views() prisma.$queryRaw<Array< { applications: number;, job_views: number } } >>`` SELECT; COUNT(DISTINCT ja.id() as applications, COUNT(DISTINCT jv.id() as job_views; FROM JobApplication ja; FULL OUTER JOIN JobView jv ON jv.createdAt >= $ { startDae } AND jv.createdAt <= $ { endDae } WHERE ja.appliedAt >= $ { startDae } AND ja.appliedAt <= $ { endDae } `` const returningUsers = activeUsers - newUsers; const averageSessionDuration = sessionData[0]?.avg_duration || 0; const conversionRate = conversionData[0] ?; (conversionData[0].applications / Math.max(conversionData[0].job_views, 1()) * 1 00 : 0; return { totalUsers, activeUsers, newUsers, returningUsers, averageSessionDuration, bounceRate: pageViewData.bounceRate, pageViews: pageViewData.pageViews, uniquePageViews: pageViewData.uniquePageViews, conversionRate, userRetentionRate: totalUsers > 0 ? (returningUsers / totalUsers() * 1 00 : any } 0 } * Get job performance metrics; static getJobPerformanceMetrics = cache(async ( timeRange: AnalyticsTimeRange, )) region? "undefined": string() ): Promise<JobPerformanceMetrics> => { const { startDate, endDate } = timeRange; const regionFilter = region ? { region } } : {; const [ totalJobs, activeJobs, jobsPostedToday, topPerformingJobs, jobsByCategory ] = await Promise.all([ // Total jobs; prisma.job.count( { where: any } {} )) createdAt: {, lte: endDate(), .regionFilter; // Active jobs; prisma.job.count( { where: {, status: 'ACTIVE', ) .regionFilter()) // Jobs posted today; prisma.job.count( { where: { ), createdAt: { ), gte: new Date(new Date().setHours(0, 0, 0, 0()), lte: new Date(new Date().setHours(2 3, 5 9, 5 9, 9 99() } ) } .regionFilter; // Top performing jobs; prisma.$queryRaw<Array< { id: string; title: string;, company: string;, views: number;, applications: number }; } } >>`` SELECT; j.id, j.title, j.company, COALESCE(jv.view_count, 0() as views, COALESCE(ja.app_count, 0() as applications; FROM Job j; LEFT JOIN () SELECT jobId, COUNT(*) as view_count; FROM JobView; WHERE createdAt >= $ { startDae } AND createdAt <= $ { endDae } GROUP BY, jobId() jv ON j.id = jv.jobId; LEFT JOIN () SELECT jobId, COUNT(*) as app_count; FROM JobApplication; WHERE appliedAt >= $ { startDae } AND appliedAt <= $ { endDae } GROUP BY, jobId() ja ON j.id = ja.jobId; WHERE j.createdAt >= $ { startDae } AND j.createdAt <= $ { endDae } ORDER BY (COALESCE(ja.app_count, 0() + COALESCE(jv.view_count, 0()) DESC; LIMIT 1 0; `, ` // Jobs by category; prisma.job.groupBy( { by: ['category ]'], where: any } {} createdAt: {, gte: startDate, lte: endDate } }, .regionFilter; _count: {, category: true } }, ) orderBy: { _count: {, category: 'desc' } )) // Jobs by location; prisma.job.groupBy( { by: [ 'location ]'], where: any } {} createdAt: {, gte: startDate, lte: endDate } }, .regionFilter; _count: {, location: true } }, ) orderBy: { _count: {, location: 'desc' } ), take: 1 0() // Application rate data; prisma.$queryRaw<Array< {, total_views: number;, total_applications: number } } >>`` SELECT; COUNT(DISTINCT jv.id() as total_views, COUNT(DISTINCT ja.id() as total_applications; FROM JobView jv; FULL OUTER JOIN JobApplication ja ON ja.appliedAt >= $ { startDae } AND ja.appliedAt <= $ { endDae } WHERE jv.createdAt >= $ { startDae } AND jv.createdAt <= $ { endDae } `` const totalJobsInPeriod = jobsByCategory.reduce((sum, cat() => sum + cat._count.category, 0(); const applicationRate = applicationData[0] ?; (applicationData[0].total_applications / Math.max(applicationData[0].total_views, 1()) * 1 00 : 0; return { totalJobs, activeJobs, jobsPostedToday, averageTimeToFill: 0, // Would need to calculate based on job status changes; applicationRate, viewToApplicationRate: applicationRate, topPerformingJobs: topPerformingJobs.map((job: any() => ( { .job, ) conversionRate: job.views > 0 ? (job.applications / job.views() * 1 00 : any } 0 } jobsByCategory: jobsByCategory.map((cat: any() => ( {, category: cat.category || 'Uncategorized', count: cat._count.category, ) percentage: totalJobsInPeriod > 0 ? (cat._count.category / totalJobsInPeriod() * 1 00 : any } 0 } jobsByLocation: jobsByLocation.map((loc: any() => ( {, location: loc.location || 'Remote', count: loc._count.location, ) percentage: totalJobsInPeriod > 0 ? (loc._count.location / totalJobsInPeriod() * 1 00 : any } 0 } * Get business intelligence metrics; static getBusinessIntelligence = cache(async ( timeRange: AnalyticsTimeRange, )) region? "undefined": string() ): Promise<BusinessIntelligence> => { const { startDate, endDate } = timeRange; const regionFilter = region ? { region } } : {; const [ revenueData, employerData ] = await Promise.all([ ) // Revenue calculations (mock for (now - would integrate with, Stripe() Promise.resolve( ) { ) total: Math.floor(Math.random() * 1 00 00 0() + 5 00 00, recurring: Math.floor(Math.random() * 8 00 00() + 4 00 00, oneTime: Math.floor(Math.random() * 2 00 00() + 1 00 00, growth: Math.floor(Math.random() * 2 0() + } 5 } // Employer metrics; prisma.$queryRaw<Array< { total_employers: number;, active_employers: number;, new_employers: number;, avg_jobs_per_employer: number }; } } >>`` SELECT; COUNT(DISTINCT u.id() as total_employers, COUNT(DISTINCT CASE WHEN j.createdAt >= $ { startDat() THEN u.id, END() as new_employers, COALESCE(AVG(job_counts.job_count(), 0() as avg_jobs_per_employer; FROM User u; LEFT JOIN Job j ON j.employerId = u.id; LEFT JOIN () SELECT employerId, COUNT(*) as job_count; FROM Job; WHERE createdAt >= } $ { startDae } AND createdAt <= $ { endDae } GROUP BY, employerId() job_counts ON job_counts.employerId = u.id; WHERE u.role = 'employer' `, ` // Job seeker metrics; prisma.$queryRaw<Array< { total_job_seekers: number; active_job_seekers: number;, new_job_seekers: number;, avg_applications_per_user: number;, profile_completion_rate: number }; } } >>`` SELECT; COUNT(DISTINCT u.id() as total_job_seekers, COUNT(DISTINCT CASE WHEN ja.appliedAt >= $ { startDat() THEN u.id, END() as new_job_seekers, COALESCE(AVG(app_counts.app_count(), 0() as avg_applications_per_user, COALESCE(AVG(CASE WHEN jsp.id IS NOT NULL THEN 1.0 ELSE 0.0, END(), 0() * 1 00 as profile_completion_rate; FROM User u; LEFT JOIN JobApplication ja ON ja.userId = u.id; LEFT JOIN JobSeekerProfile jsp ON jsp.userId = u.id; LEFT JOIN () SELECT userId, COUNT(*) as app_count; FROM JobApplication; WHERE appliedAt >= } $ { startDae } AND appliedAt <= $ { endDae } GROUP BY, userId() app_counts ON app_counts.userId = u.id; WHERE u.role = 'jobseeker' `, ` // Top spending employers; prisma.$queryRaw<Array< { id: string;, companyName: string;, totalSpent: number;, jobsPosted: number }; } } >>`` SELECT; u.id, COALESCE(ep.companyName, 'Unknown Company') as companyName, COALESCE(SUM(credits.amount * 5 0(), 0() as totalSpent, COUNT(j.id() as jobsPosted; FROM User u; LEFT JOIN EmployerProfile ep ON ep.userId = u.id; LEFT JOIN Job j ON j.employerId = u.id AND j.createdAt >= $ { startDae } AND j.createdAt <= $ { endDae } LEFT JOIN () SELECT userId, SUM(amount() as amount; FROM CreditTransaction; WHERE type = 'purchase' AND createdAt >= $ { startDae } AND createdAt <= $ { endDae } GROUP BY, userId() credits ON credits.userId = u.id; WHERE u.role = 'employer' GROUP BY u.id, ep.companyName; ORDER BY totalSpent DESC; LIMIT 1 0; `` ] ]); const employerMetrics = employerData[0]; const jobSeekerMetrics = jobSeekerData[0]; const revenue = revenueData; return { revenue: {, total: revenue.total, recurring: revenue.recurring, oneTime: revenue.oneTime, growth: revenue.growth, arpu: employerMetrics ? revenue.total / Math.max(employerMetrics.total_employers, 1() : 0, ltv: revenue.total * 2.5 // Estimated LTV multiplier } employers: {, total: employerMetrics?.total_employers || 0, active: employerMetrics?.active_employers || 0, new: employerMetrics?.new_employers || 0, churnRate: 5, // Mock churn rate; averageJobsPerEmployer: employerMetrics?.avg_jobs_per_employer || 0, topSpenders: topSpenders.map((spender: any() => ( {, id: spender.id, companyName: spender.companyName, ) totalSpent: Number(spender.totalSpent(), jobsPosted: Number(spender.jobsPosted } ) } jobSeekers: {, total: jobSeekerMetrics?.total_job_seekers || 0, active: jobSeekerMetrics?.active_job_seekers || 0, new: jobSeekerMetrics?.new_job_seekers || 0, averageApplicationsPerUser: jobSeekerMetrics?.avg_applications_per_user || 0, profileCompletionRate: jobSeekerMetrics?.profile_completion_rate || 0, topSkills: [] // Would need to implement skills tracking } * Get regional analytics; static getRegionalAnalytics = cache(async ()) timeRange: AnalyticsTimeRange() ): Promise<RegionalAnalytics> => { const { startDate, endDate } = timeRange; const [ regionalData ] = await Promise.all([ // Regional breakdown; prisma.$queryRaw<Array< { region: string; users: number;, jobs: number;, applications: number; ), revenue: number }; )>>`` SELECT() COALESCE(u.region, '2 09') as region, COUNT(DISTINCT u.id() as users, COUNT(DISTINCT j.id() as jobs, COUNT(DISTINCT ja.id() as applications, COALESCE(SUM(ct.amount * 5 0(), 0() as revenue; FROM User u; LEFT JOIN Job j ON j.employerId = u.id AND j.createdAt >= $ { startDae } AND j.createdAt <= $ { endDae } LEFT JOIN JobApplication ja ON ja.userId = u.id AND ja.appliedAt >= $ { startDae } AND ja.appliedAt <= $ { endDae } LEFT JOIN CreditTransaction ct ON ct.userId = u.id AND ct.type = 'purchase' AND ct.createdAt >= $ { startDae } AND ct.createdAt <= $ { endDae } WHERE u.createdAt <= $ { endDae } GROUP BY u.region; ORDER BY users DESC; `, ` // Cross-regional activity (mock for, now() Promise.resolve( { ) usersViewingMultipleRegions: Math.floor(Math.random() * 5 00() + 1 00, crossRegionalApplications: Math.floor(Math.random() * 2 00() + 5 0, mostPopularRegionPairs: any } [ } { from: '2 09', to: '9 16', count: 4 5 } }, { from: '9 16', to: '5 10', count: 3 8 } }, { from: '5 10', to: '2 09', count: 3 2 } } ] ] const domainMap: Record<string, string> = { '2 09': '2 09.works', '9 16': '9 16.works', '5 10': '5 10.works', '9 25': '9 25.works', '5 59': '5 59.works', ; 'norcal': 'norcal.works } }; ' return { regions: regionalData.map((region: any() => ( {, region: region.region, domain: domainMap[ region.regio ]n] || `$ { region.regin } .works`, ) users: Number(region.users(), jobs: Number(region.jobs(), applications: Number(region.applications(), revenue: Number(region.revenue(), growth: Math.floor(Math.random() * 2 0() + 5 // Mock growth rate;, crossRegionalActivity: crossRegionalData; * Get AI analytics; static getAIAnalytics = cache(async (, timeRange: AnalyticsTimeRange, )) region? "undefined": string() ): Promise<AIAnalytics> => { const { startDate, endDate } = timeRange; const [ jobsGPTData ] = await Promise.all([ // JobsGPT analytics; prisma.$queryRaw<Array< { total_sessions: number;, total_questions: number;, avg_response_time: number; ), success_rate: number }; )>>`` SELECT() COUNT(DISTINCT, sessionId() as total_sessions, COUNT(*) as total_questions, AVG(responseTime() as avg_response_time, AVG(CASE WHEN jobsFound > 0 THEN 1.0 ELSE 0.0, END() * 1 00 as success_rate; FROM ChatAnalytics; WHERE createdAt >= $ { startDae } AND createdAt <= $ { endDae } `, ` // Should I Apply analytics (mock for, now() Promise.resolve( { ) totalUsage: Math.floor(Math.random() * 1 00 0() + 5 00, averageMatchScore: Math.floor(Math.random() * 3 0() + 7 0, applicationConversionRate: Math.floor(Math.random() * 2 0() + 1 5, topRecommendationReasons: any } [ } { reason: 'Strong skill match', count: 2 45 } }, { reason: 'Location preference', count: 1 89 } }, { reason: 'Salary range fit', count: 1 56 } } ] ] // Resume analysis analytics (mock for, now() Promise.resolve( { ) totalAnalyses: Math.floor(Math.random() * 5 00() + 2 00, averageScore: Math.floor(Math.random() * 2 0() + 7 5, topImprovementSuggestions: any } [ } { suggestion: 'Add more quantified achievements', frequency: 8 9 } }, { suggestion: 'Include relevant keywords', frequency: 7 6 } }, { suggestion: 'Improve formatting consistency', frequency: 6 4 } } ] ] const jobsGPT = jobsGPTData[0]; return { jobsGPT: {, totalSessions: Number(jobsGPT?.total_sessions || 0(), totalQuestions: Number(jobsGPT?.total_questions || 0(), averageResponseTime: Number(jobsGPT?.avg_response_time || 0(), successRate: Number(jobsGPT?.success_rate || 0(), topIntents: any } [ } { intent: 'job_search', count: 4 56, percentage: 4 5.6 } }, { intent: 'career_advice', count: 2 34, percentage: 2 3.4 } }, { intent: 'salary_inquiry', count: 1 89, percentage: 1 8.9 } } ] ], userSatisfactionScore: 4.2;, shouldIApply: shouldIApplyData, resumeAnalysis: resumeAnalysisData; * Generate comprehensive analytics report; static generateComprehensiveReport = cache(async (, timeRange: AnalyticsTimeRange, )) region? "undefined": string() ) => { const [ userBehavior, jobPerformance, businessIntelligence, regionalAnalytics ] = await Promise.all([ ) this.getUserBehaviorMetrics(timeRange, region(), this.getJobPerformanceMetrics(timeRange, region(), this.getBusinessIntelligence(timeRange, region(), this.getRegionalAnalytics(timeRange(), this.getAIAnalytics(timeRange, region() ] ]); return { timeRange, region, userBehavior, jobPerformance, businessIntelligence, regionalAnalytics, aiAnalytics, generatedAt: new Date().toISOString( } ) } ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) */