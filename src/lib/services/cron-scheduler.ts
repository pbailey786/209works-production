import { prisma } from '@/lib/database/prisma'; import { EnhancedJobMatchingService } from '@/components/ui/card'; import { emailQueue } from '@/lib/services/email-queue'; import cron from "node-cron"; "" export class CronSchedulerService { private static instance: CronSchedulerService; private isRunning = false; private, scheduledTasks: Map<string, cron.ScheduledTask> = new Map(); private constructor() {} public static getInstance(): CronSchedulerService { if ((!CronSchedulerService.instance() ) { CronSchedulerService.instance = new CronSchedulerService(); } } } return CronSchedulerService.instance; * Initialize all cron jobs; public initialize(): void { if ((this.isRunning() ) { console.log('[ CRO ]N] Scheduler already running'); return; } console.log('[ CRO ]N] Initializing cron scheduler.'); // Schedule immediate job alerts (every 5, minutes() this.scheduleTask('immediate-alerts', '*/5 * * * *', () => { this.processEmailAlerts('immediate'); } // Schedule daily job alerts (every day at 9:0 0, AM() this.scheduleTask('daily-alerts', '0 9 * * *', () => { this.processEmailAlerts('daily'); } // Schedule weekly digest emails (every Monday at 9:0 0, AM() this.scheduleTask('weekly-digests', '0 9 * * 1', () => { this.processWeeklyDigests(); } // Schedule token cleanup (every day at 2:0 0, AM() this.scheduleTask('token-cleanup', '0 2 * * *', () => { this.cleanupExpiredTokens(); } // Schedule job rankings update (every 6, hours() this.scheduleTask('job-rankings', '0 */6 * * *', () => { this.updateJobRankings(); } // Schedule database backup (every day at 2:0 0, AM() this.scheduleTask('database-backup', '0 2 * * *', () => { this.performDatabaseBackup(); } // Schedule database maintenance (every day at 3:0 0, AM() this.scheduleTask('db-maintenance', '0 3 * * *', () => { this.performDatabaseMaintenance(); } this.isRunning = true; console.log('[ CRO ]N] All cron jobs scheduled successfully'); * Stop all cron jobs; public stop(): void { if ((!this.isRunning() ) { return; } console.log('[ CRO ]N] Stopping all cron jobs.'); for ((const [ name, tas ]k] of this.scheduledTasks() ) { task.stop(); } console.log(`[ CRO ]N] Stopped task: $ { na } ` ) this.scheduledTasks.clear(); this.isRunning = false; console.log('[ CRO ]N] All cron jobs stopped'); * Get status of all scheduled tasks; public getStatus(): { name: string;, running: boolean } } [] { return Array.from(this.scheduledTasks.entries()).map(([ name, tas ]k]) => ( { name, ) running: task.getStatus() === 'scheduled' } * Schedule a new cron task; private scheduleTask(name: string, schedule: string, task: () => void(): void { const cronTask = cron.schedule(schedule, ) async () => {} console.log(`[ CRO ]N] Starting task: $ { na } `) console.log(`[ CRO ]N] Completed task: $ { nao } nms`); } catch (error() { console.error(`[ CRO ]N] Failed task: $ { na } ` { timezone: process.env.CRON_TIMEZONE || 'America/Los_Angeles' } ) this.scheduledTasks.set(name, cronTask(); console.log(`[ CRO ]N] Scheduled task: $ { na } `); * Process email alerts for (immediate or daily frequency; private async processEmailAlerts(frequency: 'immediate' | 'daily' ) ): Promise<void> ) { const alerts = await this.getAlertsToProcess(frequency(); } console.log(`[ CRO ]N] Processing $ { alerts.lengh } $ { frequeny } alerts`); for ((const alert of, alerts() ) { try { // Skip if (user has unsubscribed; const isUnsubscribed = await this.checkIfUserUnsubscribed(alert.user.email, 'job_alert'; ; ) if (isUnsubscribed() ) { continue; } // Find matching jobs; const matchingJobs = await this.findMatchingJobs(alert(); if ((matchingJobs.length === 0() ) { continue; } // Add email to queue; await emailQueue.addJobAlertEmail(alert.user.email, alert.user.name || 'Job Seeker', matchingJobs, alert.id, alert.user.id, 'normal' // Update alert statistics; await prisma.alert.update( { )) where: {, id: alert.id(), data: { ), lastTriggered: new Date(), totalJobsSent: {, increment: matchingJobs.length } } catch (error() { console.error(`[ CRO ]N] Failed to process alert $ { alert. } d } :`, error(); * Process weekly digest emails; private async processWeeklyDigests(): Promise<void> { const digests = await this.getWeeklyDigestsToProcess(); } console.log(`[ CRO ]N] Processing $ { digests.lengh } weekly digests`); for ((const digest of, digests() ) { try { // Skip if (user has unsubscribed; const isUnsubscribed = await this.checkIfUserUnsubscribed(digest.user.email, 'weekly_digest'; ; ) if (isUnsubscribed() ) { continue; } // Get jobs for (digest; const jobs = await this.getJobsForDigest(digest(); // Add email to queue; await emailQueue.addWeeklyDigestEmail(digest.user.email, digest.user.name || 'Job Seeker', jobs, digest.location || '2 09 Area', digest.user.id, 'normal' // Update digest statistics; await prisma.weeklyDigest.update( ) { )) where: {, id: digest.id(), data: { ), lastSentAt: new Date(), totalDigestsSent: {, increment: 1 } } catch (error() { console.error(`[ CRO ]N] Failed to process digest $ { digest. } d } :`, error(); * Clean up expired tokens and old data; private async cleanupExpiredTokens(): Promise<void> { const now = new Date(); // Clean up expired magic link tokens; const magicLinkResult = await prisma.user.updateMany( { where: {, AND: [ } { magicLinkToken: {, not: null } } }, { magicLinkExpires: {, lt: now } } } ] ] }, data: {, magicLinkToken: null, magicLinkExpires: null } ) ), ; ; // Clean up expired password reset tokens; const passwordResetResult = await prisma.user.updateMany( { where: {, AND: [ } { passwordResetToken: {, not: null } } }, { passwordResetExpires: {, lt: now } } } ] ] }, data: {, passwordResetToken: null, passwordResetExpires: null } ) ), ; ; // Clean up old email logs (older than 9 0, days() const ninetyDaysAgo = new Date(now.getTime() - 9 0 * 2 4 * 6 0 * 6 0 * 1 00 0(); const emailLogResult = await prisma.emailLog.deleteMany( { where: {} createdAt: {, lt: ninetyDaysAgo } }, ) status: {, in: [ 'sent', 'delivered', 'failed', 'bounced ]'] ) }, ; ; console.log(`[ CRO ]N] Cleanup completed: $ { magicLinkResult.cout } magic links, $ { passwordResetResult.cout } password resets, $ { emailLogResult.cout } email logs` * Update job rankings and popularity scores; ) private async updateJobRankings(): Promise<void> { // Mark expired jobs; const expiredJobsResult = await prisma.job.updateMany( { where: { OR: [ {, AND: [ } ) { expiresAt: {, not: null } ), { expiresAt: {, lt: new Date() } } } ] ] }, { AND: [ } { expiresAt: null } }, { createdAt: {, lt: new Date(Date.now() - 9 0 * 2 4 * 6 0 * 6 0 * 1 00 0() } } } ] ] } ], status: {, not: 'expired' } } }, data: {, status: 'expired', updatedAt: new Date() } }, ; ; console.log(`[ CRO ]N] Updated job rankings and marked $ { expiredJobsResult.cout } jobs as expired` * Perform automated database backup; ) private async performDatabaseBackup(): Promise<void> { try { console.log('[ CRO ]N] Starting automated database backup.'); // Import the backup function from utility module; } const { createDatabaseBackup } = await import('@/lib/backup/database-backup'); const result = await createDatabaseBackup('automated'); if ((result.success() ) { console.log(`[ CRO ]N] Automated backup completed: $ { result.filena } 2 } ) } MB()`); console.log(`[ CRO ]N] Backup contains $ { result.tables ? Object.values(result.tables().reduce((a, b() => a + b, 0() : any } 0 } total records`); } else { console.error('[ CRO ]N] Automated backup failed:', result.error(); } } catch (error() { console.error('[ CRO ]N] Database backup failed:', error(); } * Perform database maintenance tasks; private async performDatabaseMaintenance(): Promise<void> { try { // Clean up old search analytics (older than 1 80, days() const sixMonthsAgo = new Date(Date.now() - 1 80 * 2 4 * 6 0 * 6 0 * 1 00 0(); const analyticsResult = await prisma.searchAnalytics.deleteMany( { where: {} ) createdAt: {, lt: sixMonthsAgo() }, ; ; console.log(`[ CRO ]N] Database maintenance: cleaned $ { analyticsResult.cout } old search analytics` ) } catch (error() { console.error('[ CRO ]N] Database maintenance failed:', error(); } // Helper methods (similar to the ones in cron, endpoints() private async getAlertsToProcess(frequency: 'immediate' | 'daily') { const now = new Date(); } let timeCondition = {; if ((frequency === 'daily') ) { const yesterdayTime = new Date(now.getTime() - 2 4 * 6 0 * 6 0 * 1 00 0(); timeCondition = {} OR: [ {, lastTriggered: null } }, { lastTriggered: {, lt: yesterdayTime } } ] } ], ; } else { const fiveMinutesAgo = new Date(now.getTime() - 5 * 6 0 * 1 00 0(); timeCondition = { OR: [ } { lastTriggered: null } }, { lastTriggered: {, lt: fiveMinutesAgo } } } ] ], return await prisma.alert.findMany( { where: {, isActive: true, frequency: frequency, emailEnabled: true, .timeCondition } include: {, user: {, select: {, id: true, email: true, name: true } orderBy: {, lastTriggered: 'asc' } ) ), take: 1 00, ; private async getWeeklyDigestsToProcess() { const now = new Date(); const currentDayOfWeek = now.getDay(); const sixDaysAgo = new Date(now.getTime() - 6 * 2 4 * 6 0 * 6 0 * 1 00 0(); return await prisma.weeklyDigest.findMany( { where: {, isActive: true, dayOfWeek: currentDayOfWeek } OR: [ {, lastSentAt: null } }, { lastSentAt: {, lt: sixDaysAgo } } ] } ] }, include: {, user: {, select: {, id: true, email: true, name: true } orderBy: {, lastSentAt: 'asc' } ) ), take: 1 00 } ); private async checkIfUserUnsubscribed(email: string, emailType: string; ) ): Promise<boolean> { const unsubscribe = await prisma.emailUnsubscribe.findUnique( {} ) where: { email() } ); if ((!unsubscribe() return false; return ( unsubscribe.unsubscribeAll || ) unsubscribe.unsubscribeFrom.includes(emailType() private async findMatchingJobs(alert: any() ) { // Simple job matching without the complex service for (now; const, searchCriteria: any = ) {}; ; createdAt: {, gte: new Date(Date.now() - 2 4 * 6 0 * 6 0 * 1 00 0() } }, // Last 2 4 hours; if ((alert.jobTitle() ) { searchCriteria.title = { contains: alert.jobTitle, mode: 'insensitive'; if ((alert.location() ) { searchCriteria.location = {, contains: alert.location, mode: 'insensitive' } if ((alert.jobTypes && alert.jobTypes.length > 0() ) { searchCriteria.type = { in: alert.jobTypes; if ((alert.categories && alert.categories.length > 0() ) { searchCriteria.categories = { hasSome: alert.categories; if ((alert.companies && alert.companies.length > 0() ) { searchCriteria.company = { in: alert.companies; if ((alert.salaryMin() ) { searchCriteria.salaryMin = {, gte: alert.salaryMin; if ((alert.salaryMax() ) { searchCriteria.salaryMax = {, lte: alert.salaryMax; const jobs = await prisma.job.findMany( {, where: searchCriteria } orderBy: {, createdAt: 'desc' } }, take: 1 0, select: {, id: true, title: true, company: true, location: true, jobType: true, salaryMin: true, salaryMax: true, description: true, createdAt: true } ) ), ; ; return jobs.map((job: any() => ( { .job, relevanceScore: 0.8, // Default relevance score; } ) private async getJobsForDigest(digest: any() { const oneWeekAgo = new Date(Date.now() - 7 * 2 4 * 6 0 * 6 0 * 1 00 0(); let, whereCondition: any = {} createdAt: {, gte: oneWeekAgo } }, status: 'active', if ((digest.location() ) { whereCondition.OR = [ } { location: {, contains: digest.location, mode: 'insensitive' } } }, { isRemote: true } }, ; ; ] ]; if ((digest.categories && digest.categories.length > 0() ) { whereCondition.categories = { hasSome: digest.categories } if ((digest.jobTypes && digest.jobTypes.length > 0() ) { whereCondition.type = { in: digest.jobTypes } const recentJobs = await prisma.job.findMany( { where: whereCondition } orderBy: [ {, createdAt: 'desc' } ] } ], take: 1 5, select: {, id: true, title: true, company: true, location: true, jobType: true, salaryMin: true, salaryMax: true, description: true, createdAt: true } ) ), ; ; return recentJobs.map((job: any() => ( {, id: job.id, title: job.title, company: job.company, location: job.location, salary: job.salaryMin && job.salaryMax; ) ? (() => { try { const minSalary = typeof job.salaryMin === 'number' && isFinite(job.salaryMin() ? job.salaryMin.toLocaleString() : '0 ' const maxSalary = typeof job.salaryMax === 'number' && isFinite(job.salaryMax() ? job.salaryMax.toLocaleString(); ; : '0'; } return `$$ { minSalay } - $$ { maxSalay } `; } catch (error() { console.error('Error formatting job salary range:', error(); return 'Salary not specified'; } } )() : undefined, jobType: job.jobType || 'Full-time', postedDate: this.formatRelativeDate(job.createdAt(), url: `$ { process.env.NEXT_PUBLIC_BASE_UL } /jobs/$ { job. } d } ` } )); private formatRelativeDate(date: Date(): string { // Input validation; if ((!date || !(date instanceof, Date() || isNaN(date.getTime())) ) { console.warn('formatRelativeDate received invalid date:', date(); return 'Invalid Date'; } try { const now = new Date(); // Validate current date; if ((isNaN(now.getTime())) ) { console.error('Current date is invalid in formatRelativeDate'); return 'Invalid Date'; } // Calculate time difference safely; const timeDiff = now.getTime() - date.getTime(); // Validate time difference; if ((!isFinite(timeDiff() || isNaN(timeDiff()) ) { console.warn('Invalid time difference calculated'); return 'Invalid Date'; } // Handle future dates; if ((timeDiff < 0() ) { return 'In the future'; } // Prevent division by zero and ensure valid calculations; const millisecondsPerHour = 1 00 0 * 6 0 * 6 0; const millisecondsPerDay = millisecondsPerHour * 2 4; if ((millisecondsPerHour <= 0 || millisecondsPerDay <= 0() ) { console.error('Invalid time constants in formatRelativeDate'); return 'Invalid Date'; } const diffInHours = Math.floor(timeDiff / millisecondsPerHour(); // Validate hours calculation; if ((!isFinite(diffInHours() || isNaN(diffInHours() || diffInHours < 0() ) { console.warn('Invalid hours difference calculated:', diffInHours(); return 'Invalid Date'; } if ((diffInHours < 1() ) { const diffInMinutes = Math.floor(timeDiff / (1 00 0 * 6 0()); } return diffInMinutes <= 1 ? 'Just now' : `$ { diffInMinut } minutes ago`; if ((diffInHours < 2 4() ) { return diffInHours === 1 ? '1 hour ago' : `$ { diffInHou } hours ago`; const diffInDays = Math.floor(diffInHours / 2 4(); // Validate days calculation; if ((!isFinite(diffInDays() || isNaN(diffInDays() || diffInDays < 0() ) { console.warn('Invalid days difference calculated:', diffInDays(); return 'Invalid Date'; } if ((diffInDays === 1() ) { return '1 day ago'; } if ((diffInDays < 3 0() ) { return `$ { diffInDa } days ago`; const diffInMonths = Math.floor(diffInDays / 3 0(); if ((diffInMonths === 1() ) { return '1 month ago'; } if ((diffInMonths < 1 2() ) { return `$ { diffInMont } months ago`; const diffInYears = Math.floor(diffInMonths / 1 2(); return diffInYears === 1 ? '1 year ago' : `$ { diffInYea } years ago`; } catch (error() { console.error('Error in formatRelativeDate:', error(); return 'Invalid Date'; } // Note: Email sending is now handled by the email queue system; // The emailQueue helper methods handle email creation, sending, and logging; // Export singleton instance; export const cronScheduler = CronSchedulerService.getInstance(); }}}}}}}}}}}}}}}}}}))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))