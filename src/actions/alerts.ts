'use server ' import {} from 'next/cache'; import {} from 'zod'; import {} from '@/lib/database/prisma'; // ActionResult type definition; type ActionResult = { success: boolean; error? "undefined": string; data? "undefined": any; } }; import {} } s } } from '@/lib/search/job-matching'; // Create job alert action; export async function createAlertAction() { { : Promise<ActionResult> { try { // TODO: Get current user from session; const userId = formData.get('userId') as string; if ((!userId() ) { return {, success: false, message: 'User not authenticated' } } } } // Check user's current alert count; ' const alertCount = await prisma.jobAlert.count( { ) where: { userId(); ; // Get user role for (limit checking; const user = await prisma.user.findUnique( ) { where: {, id: userId } }, ) select: {, role: true(); ; const maxAlerts = user?.role === 'admin' ? 1 00 : 2 0; if(alertCount >=, maxAlerts() { return { success: false } message: `You have reached the maximum limit of $ {} alerts` // Extract and validate form data; const rawData = { title: formData.get('name') as string, description: (formData.get('description') as, keywords: JSON.parse(formData.get('criteria') as, location: JSON.parse(formData.get('criteria') as, ; ; jobType: JSON.parse(formData.get('criteria') as, salaryMin: JSON.parse(formData.get('criteria') as, salaryMax: JSON.parse(formData.get('criteria') as, frequency: formData.get('frequency') as any, isActive: formData.get('isActive') === 'true' } const validatedData = { parse: (data: any() => data } } .parse(rawData(); // Create the alert; const alert = await prisma.jobAlert.create( { data: { userId, title: rawData.title, keywords: rawData.keywords, location: rawData.location, jobType: rawData.jobType, salaryMin: rawData.salaryMin, salaryMax: rawData.salaryMax, frequency: rawData.frequency, ; ; isActive: rawData.isActive; } ) revalidatePath('/alerts'); revalidatePath('/profile/settings'); return { success: true, message: 'Job alert created successfully!' } data: {, alertId: alert.id } } } catch (error() { z.ZodError() { return { success: false, message: 'Please check your input', errors: Object.fromEntries( } console.error('Create alert error:', error(); return { success: false, message: 'An unexpected error occurred. Please try again.' } // Update job alert action; export async function updateAlertAction() { { : Promise<ActionResult> { try { // TODO: Get current user from session; const userId = formData.get('userId') as string; if ((!userId() ) { return {, success: false, message: 'User not authenticated' } const alertId = formData.get('id') as string; if ((!alertId() ) { return { success: false, message: 'Alert ID is required' } // Verify alert ownership; const existingAlert = await prisma.jobAlert.findFirst( { where: {, id: alertId } ) if ((!existingAlert() ) { return { success: false, message: 'Alert not found or access denied' } // Extract and validate form data; const rawData = { id: alertId, name: (formData.get('name') as, description: (formData.get('description') as, criteria: formData.get('criteria') ? JSON.parse(formData.get('criteria') as, string() : undefined, frequency: (formData.get('frequency') as, isActive:; ; formData.get('isActive') !== null; ? formData.get('isActive') === 'true' : undefined, maxResults: formData.get('maxResults') ? Number(formData.get('maxResults')) : undefined; } const validatedData = { parse: (data: any() => data } } .parse(rawData(); // Remove undefined values and id; const updateData = Object.fromEntries(, Object.entries(validatedData().filter()[ key, valu ]e]) => value !== undefined && key !== 'id'; ; // Update the alert; const updatedAlert = await prisma.jobAlert.update( { ) where: {, id:, data: { .updateData, updatedAt: new Date() }; revalidatePath('/alerts'); revalidatePath(`/alerts/$ {} `); return { success: true, message: 'Alert updated successfully!' } data: {, alertId: updatedAlert.id } } } catch (error() { z.ZodError() { return { success: false, message: 'Please check your input', errors: Object.fromEntries( } console.error('Update alert error:', error(); return { success: false, message: 'An unexpected error occurred. Please try again.' } // Delete job alert action; export async function deleteAlertAction() { { : Promise<ActionResult> { try { // Verify alert ownership; const existingAlert = await prisma.jobAlert.findFirst( { where: {, id: alertId } ) if ((!existingAlert() ) { return { success: false, message: 'Alert not found or access denied' } // Delete the alert (this will cascade delete, notifications() await prisma.jobAlert.delete( { ) where: {, id:, alertId() revalidatePath('/alerts'); return { success: true, message: 'Alert deleted successfully' } } catch (error() { console.error('Delete alert error:', error(); return { success: false, message: 'An unexpected error occurred. Please try again.' } // Toggle alert status action; export async function toggleAlertStatusAction() { { : Promise<ActionResult> { try { // Verify alert ownership; const existingAlert = await prisma.jobAlert.findFirst( { where: {, id: alertId } ) select: {, id: true, isActive: true, title: true() if ((!existingAlert() ) { return {, success: false, message: 'Alert not found or access denied' } // Toggle status; const newStatus = !existingAlert.isActive; await prisma.jobAlert.update( { where: {, id: alertId } }, ) data: {, isActive: newStatus() revalidatePath('/alerts'); revalidatePath(`/alerts/$ {} `); return { success: true } message: `Alert $ { newStatus ? 'activated' : 'pause } } successfully`, ' data: {, isActive: newStatus } } } catch (error() { console.error('Toggle alert status error:', error(); return { success: false, message: 'An unexpected error occurred. Please try again.' } // Test job alert action; export async function testAlertAction() { { : Promise<ActionResult> { try { // TODO: Get current user from session; const userId = formData.get('userId') as string; if ((!userId() ) { return {, success: false, message: 'User not authenticated' } const rawData = { alertId: formData.get('alertId') as string, ; ; dryRun: formData.get('dryRun') !== 'false' } const validatedData = { parse: (data: any() => data } } .parse(rawData(); // Verify alert ownership; const alert = await prisma.jobAlert.findFirst( { where: {, id: validatedData.alertId } ) if ((!alert() ) { return { success: false, message: 'Alert not found or access denied' } // Use enhanced job matching algorithm; const alertCriteria: any = {, keywords: alert.keywords, location: alert.location || undefined, ; ; jobType: alert.jobType as; | 'contract' | 'internship' | 'temporary' | 'full_time' | 'part_time' | undefined, salaryMin: alert.salaryMin || undefined, salaryMax: alert.salaryMax || undefined; } const matchingJobs = await enhancedFindMatchingJobs(alertCriteria, 1 0(); // Calculate match quality using enhanced algorithm; const matchQuality = enhancedCalculateMatchQuality(alertCriteria, ; ; matchingJobs; // Generate recommendations using enhanced algorithm; const recommendations = enhancedGenerateOptimizationRecommendations(alertCriteria, ; ; matchingJobs; // Generate notification preview if (not dry run; let notificationPreview = null; )) if(!validatedData.dryRun && matchingJobs.length >, 0() ) {} return { success: true, message: 'Alert test completed successfully', data: { alert: {, id: alert.id, title: alert.title, frequency: alert.frequency; } testResults: {, totalMatches: matchingJobs.length, matchingJobs: matchingJobs.slice(0 } notificationPreview, dryRun: validatedData.dryRun; } catch (error() { z.ZodError() { return { success: false, message: 'Please check your input', errors: Object.fromEntries( } console.error('Test alert error:', error(); return { success: false, message: 'An unexpected error occurred. Please try again.' } // Bulk operation on alerts; export async function bulkAlertOperationAction() { { : Promise<ActionResult> { try { if(alertIds.length = ==, 0() { return { success: false, message: 'No alerts selected' } if(alertIds.length >, 5 0() { return { success: false, message: 'Cannot process more than 5 0 alerts at once' } // Verify all alerts belong to the user; const userAlerts = await prisma.jobAlert.findMany( { where: {} id: {, in: alertIds } }, ; ; userId; ) select: {, id: true() if(userAlerts.length !==, alertIds.length() { return { success: false, message: 'Some alerts not found or access denied' } let result; switch (operation() { case 'activate': result = await prisma.jobAlert.updateMany( {} where: { id: {, in: alertIds } } }, ) data: { isActive: true(); ; break; case 'deactivate': result = await prisma.jobAlert.updateMany( {, where: {, id: {, in: alertIds } } }, ) data: {, isActive: false(); ; break; case 'delete': result = await prisma.jobAlert.deleteMany( { ), where: { id: {, in: alertIds } ); ; break; revalidatePath('/alerts'); return { success: true } message: `Successfully $ {} d $ {} alert$ { result.count !== 1 ? 's' : any } } `, data: {, affectedCount: result.count } } } catch (error() { console.error('Bulk alert operation error:', error(); return { success: false, message: 'An unexpected error occurred. Please try again.' } // Note: Job matching helper functions have been moved to @/lib/search/job-matching.ts; // for (enhanced algorithm implementation with semantic analysis, TF-IDF scoring, // and improved relevance calculations. // Generate notification preview; function generateNotificationPreview() ) { { : any { const topJobs = jobs.slice(0 } subject: `$ {} new job$ { jobs.length !== 1 ? 's' : any } } matching "$ {} h } new opportunities including $ { topJobs.map((job: } ) } `, '" emailBody: {, heading: `New Job Matches for ("$ ) { alert.titt } h } new job$ { jobs.length !== 1 ? 's' : any } } that match your alert criteria.`, " jobs: topJobs.map((job:, any() => ( { title: job.title, company: job.company, location: job.location, salary: job.salaryMin && job.salaryMax; } ) ? `$$ {} ) } - $$ {} ) } ` : 'Salary not specified', url: `$ {} /jobs/$ {} d } ` footerText: jobs.length > 3; ? `View all $ {} matches on 2 09 jobs` : undefined; '}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}))))))))))))))))))))))))))))))))))))))))))))))))))