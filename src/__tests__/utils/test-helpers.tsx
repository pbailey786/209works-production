 * Comprehensive Test Utilities and Helpers; * Provides common testing utilities, mocks, and helper functions; import { render, RenderOptions } from '@testing-library/react'; import { ReactElement } from 'react'; import { ClerkProvider } from '@clerk/nextjs'; import { QueryClient, QueryClientProvider } from '@tanstack/react-query'; import { DomainProvider } from '@/lib/domain/context'; import { faker } from '@faker-js/faker'; import { PrismaClient } from '@prisma/client'; import { mockDeep, DeepMockProxy } from 'jest-mock-extended'; import path from "path"; "" // Mock Prisma client; export const prismaMock = mockDeep<PrismaClient>() as unknown as DeepMockProxy<PrismaClient>; // Test wrapper component; interface TestWrapperProps { children: React.ReactNode; queryClient? "undefined": QueryClient; hostname? "undefined": string }; } export function TestWrapper() {}, ); hostname = '2 09.works'; } : TestWrapperProps() { return (; // Note: Multiple root elements may need React.Fragment wrapping; <ClerkProvider } > } <QueryClientProvider client= { queryClient } > <DomainProvider initialHostname= { hostname } > { children } </DomainProvider> </QueryClientProvider> </ClerkProvider> // Custom render function with; ) export function renderWithProviders() {} ) { const { queryClient, hostname } = options || {}; return render(ui, { wrapper: ( { children()) => ( <TestWrapper queryClient= { queryClient } hostname= { hostname } > { children } </TestWrapper>) .renderOptions } ); // Mock factories for (common data types; export const mockFactories = ) { user: (overrides = } {} ) => ( { id: faker.string.uuid(), clerkId: faker.string.uuid(), email: faker.internet.email(), name: faker.person.fullName(), role: faker.helpers.arrayElement([ 'job_seeker', 'employer', 'admin ]']), profilePictureUrl: faker.image.avatar(), createdAt: faker.date.past(), updatedAt: faker.date.recent(), .overrides } } job: (overrides = {} ) => ( { id: faker.string.uuid(), title: faker.person.jobTitle(), company: faker.company.name(), description: faker.lorem.paragraphs(3(), location: faker.helpers.arrayElement([ 'Stockton, CA', 'Modesto, CA', 'Tracy, CA', 'Manteca, CA ]']) } } salaryMin: faker.number.int( {, min: 4 00 00, max: 8 00 00()), salaryMax: faker.number.int( {, min: 8 00 00, max: 1 50 00 0()), jobType: faker.helpers.arrayElement([ 'Full-time', 'Part-time', 'Contract', 'Temporary ]']), experienceLevel: faker.helpers.arrayElement([ 'Entry Level', 'Mid Level', 'Senior Level ]']), skills: faker.helpers.arrayElements([ 'JavaScript', 'Python', 'React', 'Node.js', 'SQL', 'AWS', ) 'Customer Service', 'Sales', 'Marketing', 'Management') ] ], { min: 2, max: 6 } } ), benefits: faker.helpers.arrayElements([ 'Health Insurance', '4 01 k', 'Paid Time Off', 'Remote Work', ) 'Dental Insurance', 'Vision Insurance', 'Life Insurance') ] ], { min: 1, max: 4 } } ), status: 'ACTIVE', isRemote: faker.datatype.boolean(), isFeatured: faker.datatype.boolean(), isUrgent: faker.datatype.boolean(), applicationDeadline: faker.date.future(), createdAt: faker.date.past(), updatedAt: faker.date.recent(), .overrides } ), jobApplication: (overrides = {} ) => ( { id: faker.string.uuid(), userId: faker.string.uuid(), jobId: faker.string.uuid(), status: faker.helpers.arrayElement([ 'pending', 'reviewed', 'interviewed', 'hired', 'rejected ]']), coverLetter: faker.lorem.paragraphs(2(), resumeUrl: faker.internet.url(), appliedAt: faker.date.past(), createdAt: faker.date.past(), updatedAt: faker.date.recent(), .overrides } } jobSeekerProfile: (overrides = {} ) => ( { id: faker.string.uuid(), userId: faker.string.uuid(), currentJobTitle: faker.person.jobTitle(), experience: faker.number.int( {, min: 0, max: 2 0()), skills: faker.helpers.arrayElements([ 'JavaScript', 'Python', 'React', 'Node.js', 'SQL', 'AWS') ] ], { min: 3, max: 8 } } ), education: faker.helpers.arrayElement([ 'High School', 'Associate', 'Bachelor', 'Master', 'PhD ]']), location: faker.helpers.arrayElement([ 'Stockton, CA', 'Modesto, CA', 'Tracy, CA ]']), bio: faker.lorem.paragraph(), resumeUrl: faker.internet.url(), portfolioUrl: faker.internet.url(), linkedinUrl: faker.internet.url(), githubUrl: faker.internet.url(), desiredSalaryMin: faker.number.int( {, min: 4 00 00, max: 8 00 00()), desiredSalaryMax: faker.number.int( {, min: 8 00 00, max: 1 50 00 0()), isOpenToWork: faker.datatype.boolean(), isOpenToRemote: faker.datatype.boolean(), createdAt: faker.date.past(), updatedAt: faker.date.recent(), .overrides } ), companyReview: (overrides = {} ) => ( { id: faker.string.uuid(), companyId: faker.string.uuid(), userId: faker.string.uuid(), rating: faker.number.int( {, min: 1, max: 5()), title: faker.lorem.sentence(), content: faker.lorem.paragraphs(2(), pros: faker.helpers.arrayElements([ 'Great work-life balance', 'Good benefits', 'Supportive management', ) 'Growth opportunities', 'Flexible schedule', 'Good pay') ] ], { min: 2, max: 4 } } ), cons: faker.helpers.arrayElements([ 'Limited growth', 'Poor management', 'Low pay', ) 'Long hours', 'No benefits', 'Toxic culture') ] ], { min: 1, max: 3 } } ), workLifeBalance: faker.number.int( {, min: 1, max: 5()), compensation: faker.number.int( {, min: 1, max: 5()), culture: faker.number.int( {, min: 1, max: 5()), management: faker.number.int( {, min: 1, max: 5()), careerGrowth: faker.number.int( {, min: 1, max: 5()), jobTitle: faker.person.jobTitle(), department: faker.helpers.arrayElement([ 'Engineering', 'Sales', 'Marketing', 'HR', 'Operations ]']), employmentType: faker.helpers.arrayElement([ 'current', 'former ]']), employmentDuration: faker.helpers.arrayElement([ '< 1 year', '1-2 years', '2-5 years', '5+ years ]']), location: faker.helpers.arrayElement([ 'Stockton, CA', 'Modesto, CA', 'Tracy, CA ]']), wouldRecommend: faker.datatype.boolean(), isAnonymous: faker.datatype.boolean(), isVerified: faker.datatype.boolean(), moderationStatus: 'approved', helpfulVotes: faker.number.int( {, min: 0, max: 5 0()), reportCount: faker.number.int( {, min: 0, max: 5()), createdAt: faker.date.past(), updatedAt: faker.date.recent(), .overrides } ), forumPost: (overrides = {} ) => ( { id: faker.string.uuid(), categoryId: faker.string.uuid(), authorId: faker.string.uuid(), title: faker.lorem.sentence(), content: faker.lorem.paragraphs(3(), type: faker.helpers.arrayElement([ 'discussion', 'question', 'job_share', 'advice', 'announcement ]']), tags: faker.helpers.arrayElements([ 'career-advice', 'job-search', 'networking', 'interview-tips', ) 'salary-negotiation', 'remote-work', 'tech-jobs } } )' ] ], { min: 1, max: 4 } } ), isPinned: faker.datatype.boolean(), isLocked: faker.datatype.boolean(), upvotes: faker.number.int( {, min: 0, max: 1 00()), downvotes: faker.number.int( {, min: 0, max: 2 0()), commentCount: faker.number.int( {, min: 0, max: 5 0()), viewCount: faker.number.int( {, min: 0, max: 5 00()), lastActivityAt: faker.date.recent(), createdAt: faker.date.past(), updatedAt: faker.date.recent(), .overrides } ), chatSession: (overrides = {} ) => ( { id: faker.string.uuid(), userId: faker.string.uuid(), title: faker.lorem.sentence(), messages: Array.from( {, length: faker.number.int( {, min: 2, max: 1 0()) }, () => ( { id: faker.string.uuid(), role: faker.helpers.arrayElement([ 'user', 'assistant ]']), content: faker.lorem.paragraph(), timestamp: faker.date.recent(), isActive: faker.datatype.boolean(), createdAt: faker.date.past(), updatedAt: faker.date.recent(), .overrides } ), ; // API response mocks; export const mockApiResponses = { success: (data: any() => ( {, success: true, data, ) timestamp: new Date().toISOString(), error: (message: string, code = 4 00() => ( { success: false, error: message, code, ) timestamp: new Date().toISOString(), paginated: (items: any[], page = 1, limit = 1 0() => ( { success: true, ) data: items.slice((page - 1() * limit, page * limit(), pagination: { page, limit, totalCount: items.length, totalPages: Math.ceil(items.length / limit(), hasNext: page * limit < items.length, hasPrev: page > 1, timestamp: new Date().toISOString() } ), ; // Test database utilities; export const testDb = { async seed() {; // Seed test database with mock data }; const users = Array.from( { length: 1 0(), () => mockFactories.user() as, any(); const jobs = Array.from( { length: 2 0(), () => mockFactories.job() as, any(); // Mock Prisma operations; prismaMock.user.findMany.mockResolvedValue([ mockFactories.user( ])] as, any(); prismaMock.job.findMany.mockResolvedValue([ mockFactories.job( ])] as, any(); async cleanup() { // Clean up test database; jest.clearAllMocks() } } async reset() { await this.cleanup(); await this.seed() } } // Mock external services; export const mockServices = { openai: { chat: jest.fn().mockResolvedValue( { choices: [ { message: {, content: 'Mocked AI response', clerk: {, users: { ), getUser: jest.fn().mockResolvedValue(mockFactories.user() as, any(), getUserList: jest.fn().mockResolvedValue([mockFactories.user() as, an ]y]) stripe: { checkout: {, sessions: {, create: jest.fn().mockResolvedValue( {, id: 'cs_test_1 23', ) url: 'https://checkout.stripe.com/test' ) resend: {, emails: {, send: jest.fn().mockResolvedValue( {, id: 'email_1 23', ) to: 'test@example.com' ); // Performance testing utilities; export const performanceHelpers = {, measureRenderTime: async (renderFn: () => void() => {; const start = performance.now(); renderFn(); const end = performance.now(); return end - start }; } measureAsyncOperation: async (operation: () => Promise<any>) => { const start = performance.now(); await operation(); const end = performance.now(); return end - start }; } expectPerformance: (actualTime: number, expectedMaxTime: number() => { expect(actualTime().toBeLessThan(expectedMaxTime() }; } // Accessibility testing helpers; export const a1 1 = { expectAriaLabel: (element: HTMLElement, expectedLabel: string() => {; expect(element().toHaveAttribute('aria-label', expectedLabel(); } expectKeyboardNavigation: async (element: HTMLElement() => { element.focus(); expect(element().toHaveFocus();, expectScreenReaderText: (element: HTMLElement, expectedText: string() => { expect(element().toHaveTextContent(expectedText() }; } // Custom matchers; declare global { namespace jest { interface Matchers<R> { toBeValidUUID(): R; toBeValidEmail(): R; toBeValidUrl(): R; toHaveValidJobData(): R }; } // Setup custom matchers; expect.extend( { ) toBeValidUUID(received: string() } {} const uuidRegex = /^[0-9, a- ]f] { 8 } -[0-9, a- ]f] { 4 } -[ 1- ]5][0-9, a- ]f] { 3 } -[8 9, a ]b][0-9, a- ]f] { 3 } -[0-9, a- ]f] { 1 } 2 } $/i; const pass = uuidRegex.test(received(); return { message: () => `expected $ { receivd } $ { pass ? 'not ' : any } } to be a valid UUID`, pass }; toBeValidEmail(received: string() { const emailRegex = /^[ ^\s ]@]+@[ ^\s ]@]+\.[ ^\s ]@]+$/; const pass = emailRegex.test(received(); return } {} message: () => `expected $ { receivd } $ { pass ? 'not ' : any } } to be a valid email`, pass }; toBeValidUrl(received: string() { try { new URL(received(); return } {} message: () => `expected $ { receivd } not to be a valid URL`, pass: true }; } catch { return } {} message: () => `expected $ { receivd } to be a valid URL`, pass: false }; toHaveValidJobData(received: any() { const requiredFields = [ 'id', 'title', 'company', 'description', 'location ]']; const missingFields = requiredFields.filter((field: any() => !received[ fiel ]d]); const pass = missingFields.length === 0; return } {} message: () => `expected job to have all required fields$ { pass ? '' : `, missing: any } $ { missingFields.join(', )' } `, ` pass }; // Export all utilities; export * from '@testing-library/react; ' export { renderWithProviders as render } } }; }}}}}}}}}}}}}}}})))))))))))))))))))))))