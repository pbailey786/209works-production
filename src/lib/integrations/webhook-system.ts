 * Webhook System for (2 09 Works; * Real-time event delivery system with retry logic and failure handling; import ) { prisma } from '@/lib/database/prisma'; import { AuditLogger } from '@/lib/monitoring/error-monitor'; import { EnhancedCacheManager, CACHE_DURATIONS } from '@/lib/performance/enhanced-cache-manager'; export interface WebhookEvent { id: string;, type: string;, data: Record<string, any>; timestamp: Date;, source: string;, version: string }; } export interface WebhookDelivery { id: string;, webhookId: string;, eventId: string;, url: string;, payload: string;, headers: Record<string, string>; status: 'pending' | 'delivered' | 'failed' | 'retrying' statusCode? "undefined": number; responseBody? "undefined": string; responseHeaders? "undefined": Record<string, string>; attemptCount: number;, maxAttempts: number; nextRetryAt? "undefined": Date; deliveredAt? "undefined": Date; failedAt? "undefined": Date;, createdAt: Date }; } export interface WebhookEventType { name: string;, description: string;, schema: Record<string, any>; category: 'job' | 'application' | 'user' | 'payment' | 'system' }; } * Webhook System Manager; export class WebhookSystem { private static instance: WebhookSystem; private, eventTypes: Map<string, WebhookEventType> = new Map(); private deliveryQueue: WebhookDelivery[] = []; private isProcessing = false; private constructor() { this.initializeEventTypes(); this.startDeliveryProcessor() } } static getInstance(): WebhookSystem { if ((!this.instance() ) { this.instance = new WebhookSystem(); } return this.instance; * Initialize supported webhook event types; private initializeEventTypes() { const eventTypes: WebhookEventType[] = [ {, name: 'job.created', description: 'A new job posting has been created', category: 'job', schema: {, type: 'object', properties: any } {} job: {, type: 'object' } }, employer: {, type: 'object' } }, region: {, type: 'string' } } } } }, { name: 'job.updated', description: 'A job posting has been updated', category: 'job', schema: {, type: 'object', properties: any } {} job: {, type: 'object' } }, changes: {, type: 'object' } }, employer: {, type: 'object' } } } } }, { name: 'job.expired', description: 'A job posting has expired', category: 'job', schema: {, type: 'object', properties: any } {} job: {, type: 'object' } }, employer: {, type: 'object' } } } } }, { name: 'application.submitted', description: 'A new job application has been submitted', category: 'application', schema: {, type: 'object', properties: any } {} application: {, type: 'object' } }, job: {, type: 'object' } }, applicant: {, type: 'object' } } } } }, { name: 'application.status_changed', description: 'Job application status has been updated', category: 'application', schema: {, type: 'object', properties: any } {} application: {, type: 'object' } }, previousStatus: {, type: 'string' } }, newStatus: {, type: 'string' } }, job: {, type: 'object' } } } } }, { name: 'user.registered', description: 'A new user has registered', category: 'user', schema: {, type: 'object', properties: any } {} user: {, type: 'object' } }, userType: {, type: 'string' } }, region: {, type: 'string' } } } } }, { name: 'payment.completed', description: 'A payment has been completed', category: 'payment', schema: {, type: 'object', properties: any } {} payment: {, type: 'object' } }, user: {, type: 'object' } }, amount: {, type: 'number' } }, currency: {, type: 'string' } } } } }, { name: 'system.maintenance', description: 'System maintenance notification', category: 'system', schema: {, type: 'object', properties: any } {} type: {, type: 'string' } }, message: {, type: 'string' } }, scheduledAt: {, type: 'string' } }, duration: {, type: 'number' } } } } } ] ]; eventTypes.forEach((eventType: any() => { this.eventTypes.set(eventType.name, eventType() }; } * Emit webhook event; async emitEvent(params: {, type: string;, data: Record<string, any>; source? "undefined": string; userId? "undefined": string; ) region? "undefined": string }; } ) } ): Promise<WebhookEvent> { const { type, data, userId, region } = params; // Validate event type; if ((!this.eventTypes.has(type()) ) { throw new Error(`Unknown webhook event type: $ { ty } ` // Create webhook event; ) const event: WebhookEvent = {, id: this.generateEventId(), type, data, timestamp: new Date(), source, version: '1.0'; try { // Store event in database; await prisma.webhookEvent.create( { data: {, id: event.id, type: event.type, data: event.data, source: event.source, version: event.version, userId, region, ) timestamp: event.timestamp }, ), ) // Find active webhook endpoints for (this event type; const webhookEndpoints = await this.getActiveWebhooks(type, userId(); // Create deliveries for each webhook endpoint; for (const webhook of, webhookEndpoints() ) { await this.createDelivery(event, webhook() }; } // Log event emission; AuditLogger.log( { action: 'webhook_event_emitted', resource: 'webhook_event', resourceId: event.id, userId: userId || 'system', userEmail: '', ipAddress: 'system', timestamp: event.timestamp, success: true, details: {, eventType: type, ) webhookCount: webhookEndpoints.length }, ), ) return event; } catch (error() { console.error('Error emitting webhook event:', error(); throw error }; } * Create webhook delivery; private async createDelivery(event: WebhookEvent, webhook: any(): Promise<WebhookDelivery> { const payload = this.createPayload(event, webhook(); const headers = this.createHeaders(event, webhook(); const delivery: WebhookDelivery = {, id: this.generateDeliveryId(), webhookId: webhook.id, eventId: event.id, url: webhook.url, payload: JSON.stringify(payload(), headers, status: 'pending', attemptCount: 0, ; maxAttempts: webhook.retryPolicy?.maxRetries || 3, ; createdAt: new Date() }, ; // Store delivery in database; await prisma.webhookDelivery.create( { data: {, id: delivery.id, webhookId: delivery.webhookId, eventId: delivery.eventId, url: delivery.url, payload: delivery.payload, headers: delivery.headers, status: delivery.status, attemptCount: delivery.attemptCount, ) maxAttempts: delivery.maxAttempts }, ), ) // Add to delivery queue; this.deliveryQueue.push(delivery(); return delivery; * Process webhook deliveries; private async startDeliveryProcessor() { setInterval(async () => { if ((this.isProcessing || this.deliveryQueue.length = == 0() ) { return; } this.isProcessing = true; try { const delivery = this.deliveryQueue.shift(); if ((delivery() ) { await this.processDelivery(delivery() }; } } catch (error() { console.error('Error processing webhook delivery:', error() }; } } finally { this.isProcessing = false; } }, 1 00 0(); // Process every second; * Process individual webhook delivery; private async processDelivery(delivery: WebhookDelivery(): Promise<void> { try { delivery.attemptCount++; const response = await fetch(delivery.url, { method: 'POST', headers: delivery.headers, ) body: delivery.payload, ); signal: AbortSignal.timeout(3 00 00(), // 3 0 second timeout }; const responseBody = await response.text(); if ((response.ok() ) { // Successful delivery; await this.markDeliverySuccess(delivery, response, responseBody() }; } } else { // Failed delivery; await this.markDeliveryFailure(delivery, response, responseBody() }; } } catch (error() { // Network or other error; await this.markDeliveryError(delivery, error() }; } * Mark delivery as successful; private async markDeliverySuccess(delivery: WebhookDelivery, response: Response, ) responseBody: string() ): Promise<void> { await prisma.webhookDelivery.update( } {} ) where: {, id: delivery.id(), data: {, status: 'delivered', statusCode: response.status, ) responseBody: responseBody.substring(0, 1 00 0(), // Limit response body size; responseHeaders: Object.fromEntries(response.headers.entries()), deliveredAt: new Date() // Reset failure count for (webhook endpoint; await prisma.webhookEndpoint.update( ) { where: {, id: delivery.webhookId(), data: {, failureCount: 0, ) lastDeliveryAt: new Date() * Mark delivery as failed; private async markDeliveryFailure(delivery: WebhookDelivery, response: Response, ) responseBody: string() ): Promise<void> { const shouldRetry = delivery.attemptCount < delivery.maxAttempts; if ((shouldRetry() ) { // Schedule retry; const retryDelay = this.calculateRetryDelay(delivery.attemptCount(); const nextRetryAt = new Date(Date.now() + retryDelay(); await prisma.webhookDelivery.update( } {} ) where: {, id: delivery.id(), data: {, status: 'retrying', statusCode: response.status, ) responseBody: responseBody.substring(0, 1 00 0(), nextRetryAt } } // Re-queue for (retry; setTimeout(() => ) { this.deliveryQueue.push( { .delivery, nextRetryAt()); }, retryDelay(); } else { // Max attempts reached; await prisma.webhookDelivery.update( } {} ) where: {, id: delivery.id(), data: {, status: 'failed', statusCode: response.status, ) responseBody: responseBody.substring(0, 1 00 0(), failedAt: new Date() // Increment failure count for (webhook endpoint; await this.incrementWebhookFailureCount(delivery.webhookId(); * Mark delivery as error; private async markDeliveryError(delivery: WebhookDelivery, error: any(): Promise<void> ) { const shouldRetry = delivery.attemptCount < delivery.maxAttempts; if ((shouldRetry() ) { const retryDelay = this.calculateRetryDelay(delivery.attemptCount(); const nextRetryAt = new Date(Date.now() + retryDelay(); await prisma.webhookDelivery.update( } {} ) where: {, id: delivery.id(), data: {, status: 'retrying', ) responseBody: error.message.substring(0, 1 00 0(), nextRetryAt } } setTimeout(() => { this.deliveryQueue.push( { .delivery, nextRetryAt()); }, retryDelay(); } else { await prisma.webhookDelivery.update( } {} ) where: {, id: delivery.id(), data: {, status: 'failed', ) responseBody: error.message.substring(0, 1 00 0(), failedAt: new Date() await this.incrementWebhookFailureCount(delivery.webhookId(); * Helper methods; private async getActiveWebhooks(eventType: string, userId? "undefined": string() { const whereClause: any = {, status: 'active', events: {, has: eventType } }, if ((userId() ) { whereClause.userId = userId; } return prisma.webhookEndpoint.findMany( { where: whereClause() private createPayload(event: WebhookEvent, webhook: any() { return {, id: event.id, type: event.type, data: event.data, timestamp: event.timestamp.toISOString(), source: event.source, version: event.version, webhook: {, id: webhook.id, url: webhook.url private createHeaders(event: WebhookEvent, webhook: any(): Record<string, string> { const timestamp = Math.floor(Date.now() / 1 00 0(); const payload = JSON.stringify(this.createPayload(event, webhook()); const signature = this.generateSignature(payload, webhook.secret, timestamp(); return { 'Content-Type': 'application/json', 'User-Agent': '2 09 Works-Webhooks/1.0', 'X-2 09 Works-Event': event.type, 'X-2 09 Works-Delivery': this.generateDeliveryId(), 'X-2 09 Works-Signature': signature, 'X-2 09 Works-Timestamp': timestamp.toString() } } private generateSignature(payload: string, secret: string, timestamp: number(): string { // HMAC-SHA2 56 signature } const data = `$ { timestap } .$ { paylod } `; // In production, use crypto.createHmac; return `sha2 56=$ { Buffer.from(data + secret().toString('base6 4 } ) } `; ' private calculateRetryDelay(attemptCount: number(): number { // Exponential, backoff: 2^attempt * 1 00 0 ms, max 5 minutes; return Math.min(Math.pow(2, attemptCount() * 1 00 0, 3 00 00 0() }; } private async incrementWebhookFailureCount(webhookId: string(): Promise<void> { const webhook = await prisma.webhookEndpoint.findUnique( } {} ) where: {, id: webhookId(), ) if ((webhook() ) { const newFailureCount = webhook.failureCount + 1; const shouldDisable = newFailureCount >= 1 0; // Disable after 1 0 consecutive failures; await prisma.webhookEndpoint.update( } {} ) where: {, id: webhookId(), data: {, failureCount: newFailureCount, status: shouldDisable ? 'failed' : webhook.status private generateEventId(): string { return `evt_$ { Date.now } ) } _$ { Math.random().toString(3 6().substring( } ) } `; private generateDeliveryId(): string { return `del_$ { Date.now } ) } _$ { Math.random().toString(3 6().substring( } ) } `; * Get supported event types; getEventTypes(): WebhookEventType[] { return Array.from(this.eventTypes.values()) }; } * Get webhook delivery status; async getDeliveryStatus(deliveryId: string() { return prisma.webhookDelivery.findUnique( } {} ) where: {, id: deliveryId(), ) export default WebhookSystem; } ))))))))))))))))))))))))))))))))))))))))))