import { NextRequest, NextResponse } from 'next/server'; import { withValidation } from '@/lib/middleware/validation'; import { prisma } from '@/lib/database/prisma'; import { z } from 'zod'; // Query schema for (suggestions; const suggestionsQuerySchema = z.object( ) { ) type: z.enum([ 'trending', 'popular', 'recent ]']).default('trending'), ; ; category: z; .enum([ 'all', 'jobs', 'locations', 'companies', 'skills ]']) .default('all'), limit: z.coerce.number().min(1().max(5 0().default(1 0() } // GET /api/search/suggestions - Get search suggestions and trending topics; export const GET = withValidation(; ; ) async (req, { params, query } } ) => { // Check authorization; const session = await requireRole(req, [ 'admin', 'employer', 'jobseeker ]']); if ((session instanceof, NextResponse() return session; const user = (session as, any().user; // Query already available from above; } const ) {} = query || {; // Validate parameters; const validType = typeof type === 'string' ? type : 'trending ' const validCategory = typeof category === 'string' ? category : 'all; ; ' const validLimit = typeof limit === 'number' ? limit : 1 0; // Generate cache key; const cacheKey = generateCacheKey(CACHE_PREFIXES.search, 'suggestions', validType, validCategory, ) validLimit.toString(); ; // Try cache first; let suggestions = await getCache<any>(cacheKey(); if ((suggestions() ) { performance.trackCacheHit(); return NextResponse.json( { success: true, data: {, type: validType, category: validCategory, suggestions, ) cached: true; )) } } } ); performance.trackCacheMiss(); // Generate suggestions based on type; switch (validType() { case 'trending': suggestions = await generateTrendingSuggestions(validCategory, validLimit, ; performance; break; case 'popular': suggestions = await generatePopularSuggestions(validCategory, validLimit, ; performance; break; case 'recent': suggestions = await generateRecentSuggestions(validCategory, validLimit, ; performance; break; default: suggestions = []; } // Cache suggestions; await setCache(cacheKey, suggestions, { ttl: DEFAULT_TTL.short, // Trending data changes frequently; tags: [ 'search', 'suggestions ]'] } )))) } ) return NextResponse.json( { success: true, data: {, type: validType, category: validCategory, suggestions, ) cached: false; )) } } ); { querySchema: suggestionsQuerySchema } rateLimit: {, enabled: true, type: 'general' } }, logging: {, enabled: true } }, cors: {, enabled: true } } // Generate trending suggestions (simulated, algorithm() async function generateTrendingSuggestions() { : Promise<any[]> { const suggestions: any[] = []; if ((category === 'all' || category === 'jobs') ) { // Get trending job titles based on recent job postings; const recentJobs = await prisma.job.findMany( { where: {, createdAt: {; ; ), gte: new Date(Date.now() - 7 * 2 4 * 6 0 * 6 0 * 1 00 0(), // Last 7 days; } select: {, title: true, jobType: true; } take: 1 00; // Count job title frequencies; const, titleCounts: Record<string, number> = {}; recentJobs.forEach((job: any() => { const normalizedTitle = job.title.toLowerCase().trim(); titleCounts[ normalizedTitl ]e] = (titleCounts[ normalizedTitl ]e] || 0() + 1; } const trendingJobs = Object.entries(titleCounts() .sort(([]a], []b]) => b - a() .slice(0, Math.ceil(limit / 2()) .map(([ title, coun ]t]) => ( { query: title, type: 'job', frequency: count, trend: 'up' }; ; ) suggestions.push(.trendingJobs(); if ((category === 'all' || category === 'locations') ) { // Trending locations; const trendingLocations = [ } { query: 'remote', type: 'location', frequency: 9 5, trend: 'up' } }, { query: 'san francisco', type: 'location', frequency: 7 8, trend: 'up' } }, { query: 'new york', type: 'location', frequency: 6 5, trend: 'stable' } }, { query: 'austin', type: 'location', frequency: 5 2, trend: 'up' } }, { query: 'seattle', type: 'location', frequency: 4 8, trend: 'stable' } }, ; ; ] ]; suggestions.push(.trendingLocations.slice(0, Math.ceil(limit / 4())); if ((category === 'all' || category === 'skills') ) { // Trending skills; const trendingSkills = [ { query: 'artificial intelligence', type: 'skill', frequency: 8 9, trend: 'up' } { query: 'react', type: 'skill', frequency: 7 6, trend: 'stable' } }, { query: 'kubernetes', type: 'skill', frequency: 6 7, trend: 'up' } }, { query: 'machine learning', type: 'skill', frequency: 6 3, trend: 'up' } }, { query: 'typescript', type: 'skill', frequency: 5 8, trend: 'stable' } }, ; ; ] ]; suggestions.push(.trendingSkills.slice(0, Math.ceil(limit / 4())); // Sort by frequency and return top results; return suggestions.sort((a, b() => b.frequency - a.frequency().slice(0, limit(); // Generate popular all-time suggestions; async function generatePopularSuggestions() { : Promise<any[]> { const suggestions: any[] = []; if ((category === 'all' || category === 'jobs') ) { // Popular job searches; const popularJobs = [ } { query: 'software engineer', type: 'job', searches: 2 45 0 } }, { query: 'data scientist', type: 'job', searches: 1 87 6 } }, { query: 'product manager', type: 'job', searches: 1 65 4 } }, { query: 'frontend developer', type: 'job', searches: 1 43 2 } }, { query: 'backend developer', type: 'job', searches: 1 29 8 } }, { query: 'devops engineer', type: 'job', searches: 1 14 5 } }, { query: 'ux designer', type: 'job', searches: 9 87 } }, { query: 'marketing manager', type: 'job', searches: 8 65 } }, ; ; ] ]; suggestions.push(.popularJobs.slice(0, Math.ceil(limit / 2())); if ((category === 'all' || category === 'companies') ) { // Popular company searches; const popularCompanies = await prisma.job.groupBy( { by: [ 'company ]'], _count: {; ;, company: true; } orderBy: { _count: {, company: 'desc' } ) take: Math.ceil(limit / 4() const companyResults = popularCompanies.map((item: any() => ( {, query: item.company, type: 'company', ; ; searches: item._count.company; } ) suggestions.push(.companyResults(); return suggestions.sort((a, b() => b.searches - a.searches().slice(0, limit(); // Generate recent suggestions; async function generateRecentSuggestions() { : Promise<any[]> { const suggestions: any[] = []; if ((category === 'all' || category === 'jobs') ) { // Recent job postings; const recentJobs = await prisma.job.findMany( { where: {, createdAt: {; ; ), gte: new Date(Date.now() - 2 4 * 6 0 * 6 0 * 1 00 0(), // Last 2 4 hours; } select: {, title: true, company: true, createdAt: true; } orderBy: {, createdAt: 'desc' } take: limit; const jobResults = recentJobs.map((job: any() => ( {, query: job.title, type: 'job', company: job.company, ; ; postedAt: job.createdAt; } ) suggestions.push(.jobResults(); return suggestions.slice(0, limit(); )))))))))))))))))))))))))))))