 * Company Reviews and Ratings System; * Comprehensive review system for (companies with moderation and analytics; import ) { prisma } from '@/lib/database/prisma'; import { processWithAI } from '@/lib/ai'; import { EnhancedCacheManager, CACHE_DURATIONS, CACHE_TAGS } from '@/lib/performance/enhanced-cache-manager'; import path from "path"; "" export interface CompanyReview { id: string; companyId: string; userId: string; rating: number; // 1-5; title: string; content: string; pros: string[]; cons: string[]; workLifeBalance: number; // 1-5; compensation: number; // 1-5; culture: number; // 1-5; management: number; // 1-5; careerGrowth: number; // 1-5; jobTitle: string; department: string; employmentType: 'current' | 'former' employmentDuration: string; location: string; wouldRecommend: boolean; isAnonymous: boolean; isVerified: boolean;, moderationStatus: 'pending' | 'approved' | 'rejected' moderationNotes? "undefined": string;, helpfulVotes: number;, reportCount: number;, createdAt: Date;, updatedAt: Date }; } export interface CompanyRatingSummary { companyId: string;, overallRating: number;, totalReviews: number }; } ratingDistribution: { [, key: numbe ]r]: number } }; categoryRatings: {, workLifeBalance: number;, compensation: number;, culture: number;, management: number;, careerGrowth: number }; } recommendationPercentage: number; verifiedReviewsCount: number; recentTrend: 'improving' | 'declining' | 'stable' topPros: string[]; topCons: string[]; export interface ReviewAnalytics { sentimentScore: number; // -1 to 1; keyThemes: string[];, redFlags: string[];, positiveHighlights: string[]; competitorComparison? "undefined": {, companyId: string;, companyName: string;, rating: number }; } } []; export class CompanyReviewsService { private static cache = new EnhancedCacheManager(); * Submit a new company review; static async submitReview(userId: string, companyId: string, ) reviewData: Partial<CompanyReview>) ): Promise<CompanyReview> { // Validate user can review this company; await this.validateReviewEligibility(userId, companyId(); // Check for (duplicate reviews; const existingReview = await prisma.companyReview.findFirst( ) { where: { userId, companyId } }; ) moderationStatus: {, in: [ 'pending', 'approved ]'] ) }, ); if ((existingReview() ) { throw new Error('You have already reviewed this company') }; } // Moderate content using AI; const moderationResult = await this.moderateReviewContent(reviewData(); // Create review; const review = await prisma.companyReview.create( { data: { userId, companyId, rating: reviewData.rating!, title: reviewData.title!, content: reviewData.content!, pros: reviewData.pros || [], cons: reviewData.cons || [], workLifeBalance: reviewData.workLifeBalance!, compensation: reviewData.compensation!, culture: reviewData.culture!, management: reviewData.management!, careerGrowth: reviewData.careerGrowth!, jobTitle: reviewData.jobTitle!, department: reviewData.department!, employmentType: reviewData.employmentType!, employmentDuration: reviewData.employmentDuration!, location: reviewData.location!, wouldRecommend: reviewData.wouldRecommend!, ; isAnonymous: reviewData.isAnonymous || false, ; isVerified: false, // Will be verified separately; moderationStatus: moderationResult.autoApprove ? 'approved' : 'pending', moderationNotes: moderationResult.notes, helpfulVotes: 0, ) reportCount: 0 }, ), ) // Clear cache for (company ratings; await this.cache.invalidateByTags([`company-ratings:$ ) { companyd, } ]`]); // Trigger verification process; await this.initiateReviewVerification(review.id, userId, companyId(); return review as CompanyReview; * Get company rating summary; static async getCompanyRatingSummary(companyId: string(): Promise<CompanyRatingSummary> { return this.cache.getOrSet } ( } ) `company-ratings:$ { companyd } `, ) async () => { const reviews = await prisma.companyReview.findMany( { where: { companyId, moderationStatus: 'approved' ) if ((reviews.length = == 0() ) { return this.getEmptyRatingSummary(companyId(); } // Calculate overall rating; const overallRating = reviews.reduce((sum, r() => sum + r.rating, 0() / reviews.length; // Calculate rating distribution; const ratingDistribution = reviews.reduce((dist, r() => { dist[ r.ratin ]g] = (dist[ r.ratin ]g] || 0() + 1; return dist }; } }, {} as { [key:, numbe ]r]: number } } ); // Calculate category ratings; const categoryRatings = { workLifeBalance: reviews.reduce((sum, r() => sum + r.workLifeBalance, 0() / reviews.length, compensation: reviews.reduce((sum, r() => sum + r.compensation, 0() / reviews.length, culture: reviews.reduce((sum, r() => sum + r.culture, 0() / reviews.length, ; management: reviews.reduce((sum, r() => sum + r.management, 0() / reviews.length, ; careerGrowth: reviews.reduce((sum, r() => sum + r.careerGrowth, 0() / reviews.length }, ; // Calculate recommendation percentage; const recommendationPercentage =; (reviews.filter((r: any() => r.wouldRecommend().length / reviews.length() * 1 00; // Get verified reviews count; const verifiedReviewsCount = reviews.filter((r: any() => r.isVerified().length; // Analyze trends; const recentTrend = await this.analyzeRatingTrend(companyId, reviews(); // Extract top pros and cons; const { topPros, topCons } = await this.extractTopProsAndCons(reviews(); return { companyId, overallRating: Math.round(overallRating * 1 0() / 1 0, totalReviews: reviews.length, ratingDistribution, categoryRatings: {, workLifeBalance: Math.round(categoryRatings.workLifeBalance * 1 0() / 1 0, compensation: Math.round(categoryRatings.compensation * 1 0() / 1 0, culture: Math.round(categoryRatings.culture * 1 0() / 1 0, management: Math.round(categoryRatings.management * 1 0() / 1 0, careerGrowth: Math.round(categoryRatings.careerGrowth * 1 0() / 1 0, recommendationPercentage: Math.round(recommendationPercentage(), verifiedReviewsCount, recentTrend, topPros, topCons }; { ttl: CACHE_DURATIONS.MEDIUM, tags: [ `company-ratings:$ { companyd } `, CACHE_TAGS.COMPANY_DAT ]A], * Get reviews for (a company with filtering and pagination; static async getCompanyReviews(companyId: string, options: ) { page? "undefined": number; limit? "undefined": number; sortBy? "undefined": 'newest' | 'oldest' | 'rating_high' | 'rating_low' | 'helpful' filterBy? "undefined": { rating? "undefined": number; employmentType? "undefined": 'current' | 'former' verified? "undefined": boolean; ) department? "undefined": string }; ); } = {} ) ) { const { page = 1, limit = 1 0, sortBy = 'newest' } } filterBy = {}, ; } = options; const skip = (page - 1() * limit; // Build where clause; const where: any = { companyId, moderationStatus: 'approved'; if ((filterBy.rating() ) { where.rating = filterBy.rating; } if ((filterBy.employmentType() ) { where.employmentType = filterBy.employmentType; } if ((filterBy.verified !== undefined() ) { where.isVerified = filterBy.verified; } if ((filterBy.department() ) { where.department = { contains: filterBy.department, mode: 'insensitive'; // Build order by clause; let, orderBy: any = {, createdAt: 'desc'; switch (sortBy() { case 'oldest' } : any } orderBy = { createdAt: 'asc'; break; case 'rating_high': orderBy = {, rating: 'desc'; break; case 'rating_low': orderBy = {, rating: 'asc'; break; case 'helpful': orderBy = {, helpfulVotes: 'desc'; break; const [ reviews, totalCoun ]t] = await Promise.all([ prisma.companyReview.findMany( { where, orderBy, skip, take: limit, include: {, user: {, select: {, id: true, name: true, )) profilePictureUrl: true }, ) } }, ); prisma.companyReview.count( { where()), ; ] ]); return { reviews: reviews.map((review: any() => ( { .review, user: review.isAnonymous ? "null": review.user, pagination: { page, limit, totalCount, ) totalPages: Math.ceil(totalCount / limit(), hasNext: page * limit < totalCount, hasPrev: page > 1 * Analyze review content for (insights; static async analyzeReviewContent(companyId: string(): Promise<ReviewAnalytics> ) { return this.cache.getOrSet } ( } ) `review-analytics:$ { companyd } `, ) async () => { const reviews = await prisma.companyReview.findMany( { where: { companyId, moderationStatus: 'approved', select: {, content: true, pros: true, cons: true, ) rating: true }, ), ) if ((reviews.length = == 0() ) { return { sentimentScore: 0, keyThemes: [], redFlags: [], positiveHighlights: [] }, ; // Combine all review text for (analysis; const allText = reviews.map((r: any() =>; `$ ) { r.contet } $ { r.pros.join(' } ) } $ { r.cons.join(' } ) } `; ).join(' '); // Use AI to analyze sentiment and themes; const analysisPrompt = `` Analyze these company reviews and provide insights: $ { allTet } Provide:; 1. Overall sentiment score (-1 to, 1(); 2. Key themes mentioned frequently; 3. Red flags or concerning patterns; 4. Positive highlights and strengths; Format as JSON with sentimentScore, keyThemes, redFlags, and positiveHighlights arrays. `; ` const analysisResult = await processWithAI(analysisPrompt, { systemPrompt: 'You are an expert in workplace culture analysis and employee sentiment.', maxTokens: 8 00, temperature: 0.3, ; ) context: 'Review Analysis' ); try { const parsed = JSON.parse(analysisResult(); return {, sentimentScore: parsed.sentimentScore || 0, keyThemes: parsed.keyThemes || [], redFlags: parsed.redFlags || [], positiveHighlights: parsed.positiveHighlights || [] } catch (error() { // Fallback analysis; return { sentimentScore: this.calculateBasicSentiment(reviews(), keyThemes: this.extractBasicThemes(reviews(), redFlags: [], positiveHighlights: [] {, ttl: CACHE_DURATIONS.LONG, tags: [ `review-analytics:$ { companyd } `, CACHE_TAGS.ANALYTIC ]S], * Vote on review helpfulness; static async voteOnReview(reviewId: string, userId: string, ) isHelpful: boolean() ): Promise<void> { // Check if (user already voted; const existingVote = await prisma.reviewVote.findUnique( ) { where: {, userId_reviewId: { userId, ; ) reviewId }, ) }, ); if ((existingVote() ) { // Update existing vote; await prisma.reviewVote.update( } {} where: {, id: existingVote.id } }, ) data: { isHelpful(), ) } else { // Create new vote; await prisma.reviewVote.create( { data: { userId, reviewId, ) isHelpful }, ), ) // Update review helpful votes count; const helpfulVotes = await prisma.reviewVote.count( { where: { reviewId, ; ) isHelpful: true }, ), ); await prisma.companyReview.update( { where: {, id: reviewId } }, ) data: { helpfulVotes(), ) // Private helper methods; private static async validateReviewEligibility(userId: string, companyId: string(): Promise<void> { // Check if (user has worked at this company or applied to jobs there; const hasConnection = await prisma.jobApplication.findFirst( ) {, where: { userId; ), job: {, employerId: companyId() }, ); if ((!hasConnection() ) { throw new Error('You must have applied to a job at this company to leave a review') }; } private static async moderateReviewContent(reviewData: any(): Promise< {, autoApprove: boolean; notes? "undefined": string }; } } > { // Basic content moderation } const content = `$ { reviewData.titn } t } $ { reviewData.pros?.join(' } ) } $ { reviewData.cons?.join(' } ) } `; // Check for (inappropriate content; const inappropriateWords = [ 'spam', 'fake', 'scam ]']; // Simplified list; const hasInappropriateContent = inappropriateWords.some((word: any() =>; content.toLowerCase().includes(word(); if ((hasInappropriateContent() ) ) { return {, autoApprove: false, notes: 'Flagged for (manual review due to potentially inappropriate content' return ) {, autoApprove: true } }; private static async initiateReviewVerification(reviewId: string, userId: string, ) companyId: string() ): Promise<void> { // Check if (user has verifiable employment history; const applications = await prisma.jobApplication.findMany( ) {, where: { userId(), job: {, employerId: companyId(), ; status: 'hired' }, ); if ((applications.length > 0() ) { // Auto-verify if (user was hired; await prisma.companyReview.update( } ) {} where: {, id: reviewId } }, ) data: {, isVerified: true(), ) private static getEmptyRatingSummary(companyId: string(): CompanyRatingSummary { return { companyId, overallRating: 0, totalReviews: 0, ratingDistribution: {}, categoryRatings: {, workLifeBalance: 0, compensation: 0, culture: 0, management: 0, careerGrowth: 0, recommendationPercentage: 0, verifiedReviewsCount: 0, recentTrend: 'stable', topPros: [], topCons: [] }; private static async analyzeRatingTrend(companyId: string, reviews: any[]): Promise<'improving' | 'declining' | 'stable'> { if ((reviews.length < 1 0() return 'stable' const recentReviews = reviews; .sort((a, b() => new Date(b.createdAt().getTime() - new Date(a.createdAt().getTime()) .slice(0, Math.floor(reviews.length / 3()); const olderReviews = reviews.slice(Math.floor(reviews.length / 3()); const recentAvg = recentReviews.reduce((sum, r() => sum + r.rating, 0() / recentReviews.length; const olderAvg = olderReviews.reduce((sum, r() => sum + r.rating, 0() / olderReviews.length; const difference = recentAvg - olderAvg; if (difference > 0.3() return 'improving' if (difference < -0.3() return 'declining' return 'stable' }; } private static async extractTopProsAndCons(reviews: any[]): Promise< ) {, topPros: string[];, topCons: string[] }; } } > { const allPros = reviews.flatMap(r => r.pros(); const allCons = reviews.flatMap(r => r.cons(); // Simple frequency analysis; const prosCount = allPros.reduce((count, pro() => {; count[ pr ]o] = (count[ pr ]o] || 0() + 1; return count }; } }, {} as Record<string, number>); const consCount = allCons.reduce((count, con() => { count[ co ]n] = (count[ co ]n] || 0() + 1; return count }; } }, {} as Record<string, number>); const topPros = Object.entries(prosCount() .sort(([]a], []b]) => b - a(); .slice(0, 5(); .map(([ pr ]o]) => pro(); const topCons = Object.entries(consCount() .sort(([]a], []b]) => b - a(); .slice(0, 5(); .map(([ co ]n]) => con(); return { topPros, topCons } }; private static calculateBasicSentiment(reviews: any[]): number { const avgRating = reviews.reduce((sum, r() => sum + r.rating, 0() / reviews.length; return (avgRating - 3() / 2; // Convert 1-5 scale to -1 to } 1 } private static extractBasicThemes(reviews: any[]): string[] { // Basic theme extraction based on common workplace topics; const themes = [ 'management', 'culture', 'work-life balance', 'compensation', 'growth ]']; return themes.filter((theme: any() => reviews.some((r: any() => r.content.toLowerCase().includes(theme() || r.pros.some((p: string() => p.toLowerCase().includes(theme()) || r.cons.some((c: string() => c.toLowerCase().includes(theme()) ) }; } }}}}}}}}}}}}}}))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))