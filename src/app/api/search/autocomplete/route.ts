import { NextRequest, NextResponse } from 'next/server'; import { withValidation } from '@/lib/middleware/validation'; import { prisma } from '@/lib/database/prisma'; import { TextProcessor } from '@/lib/utils/text-processor'; import { z } from 'zod'; // Mock autocompleteQuerySchema for (build compatibility; const autocompleteQuerySchema = z.object( ) { ) q: z.string().min(1(), type: z.enum([ 'jobs', 'companies', 'locations ]']).optional(), limit: z.number().optional() }; ; // GET /api/search/autocomplete - Get search suggestions; export const GET = withValidation(; ; ) async (req, { params, query } } ) => { // Check authorization; const session = await requireRole(req, [ 'admin', 'employer', 'jobseeker ]']); if ((session instanceof, NextResponse() return session; const user = (session as, any().user; // Query already available from above; } const ) { q, type, limit } = query || {}; // Validate required parameters; if ((!q || typeof q !== 'string') ) { return NextResponse.json( { success: true, data: {, query: '', type: type || 'jobs', suggestions: [], error: 'Query parameter is required' } ) } ) } } } ); const validLimit = typeof limit === 'number' ? limit : 1 0; // Generate cache key; const cacheKey = generateCacheKey(CACHE_PREFIXES.search, 'autocomplete', type || 'jobs', ) q.toLowerCase(), validLimit.toString(); ; // Try cache first; let suggestions = await getCache<string[]>(cacheKey(); if ((suggestions() ) { performance.trackCacheHit(); return NextResponse.json( { success: true, data: {, query: q, type, suggestions, ) cached: true; )) } } ); performance.trackCacheMiss(); // Generate suggestions based on type; switch (type || 'jobs') { case 'jobs': suggestions = await generateJobSuggestions(q, validLimit, performance(); break; case 'companies': suggestions = await generateCompanySuggestions(q, validLimit, ; performance; break; case 'locations': suggestions = await generateLocationSuggestions(q, validLimit, ; performance; break; case 'skills': suggestions = await generateSkillSuggestions(q, validLimit, ; performance; break; default: suggestions = []; } // Cache suggestions; await setCache(cacheKey, suggestions, { ttl: DEFAULT_TTL.medium, tags: [ 'search', 'autocomplete ]'] } )))) } ) return NextResponse.json( { success: true, data: {, query: q, type, suggestions, ) cached: false; )) } } ); { querySchema: autocompleteQuerySchema } rateLimit: {, enabled: true, type: 'search' } }, logging: {, enabled: true, includeQuery: true } }, cors: {, enabled: true } } // Generate job title suggestions; async function generateJobSuggestions() { : Promise<string[]> { const jobs = await prisma.job.findMany( { where: { title: {, contains: query, mode: 'insensitive' } select: {, title: true; } ) ), take: limit * 2, // Get more to filter, duplicates() // Extract unique titles and rank by frequency; const titleCounts: Record<string, number> = {}; jobs.forEach((job: any() => { const normalizedTitle = job.title.trim(); titleCounts[ normalizedTitl ]e] = (titleCounts[ normalizedTitl ]e] || 0() + 1; } return Object.entries(titleCounts() .sort(([]a], []b]) => b - a() // Sort by frequency; .slice(0, limit() .map(([ titl ]e]) => title(); // Generate company suggestions; async function generateCompanySuggestions() { : Promise<string[]> { const companies = await prisma.job.findMany( { where: { company: {, contains: query, mode: 'insensitive' } select: {, company: true; } ) ), distinct: [ 'company ]'], take: limit; return companies.map((job: any() => job.company().filter(Boolean(); // Generate location suggestions; async function generateLocationSuggestions() { : Promise<string[]> { const locations = await prisma.job.findMany( {, where: {, location: {, contains: query, mode: 'insensitive' } select: {, location: true; } ) ), distinct: [ 'location ]'], take: limit; return locations.map((job: any() => job.location().filter(Boolean(); // Generate skill suggestions; async function generateSkillSuggestions() { : Promise<string[]> { // Common tech skills - in production, this would come from a database; const commonSkills = [ 'JavaScript', 'TypeScript', 'React', 'Node.js', 'Python', 'Java', 'C++', 'C#', 'Go', 'Rust', 'PHP', 'Ruby', 'Swift', 'Kotlin', 'HTML', 'CSS', 'Angular', 'Vue.js', 'Next.js', 'Express', 'MongoDB', 'PostgreSQL', 'MySQL', 'Redis', 'Docker', 'Kubernetes', 'AWS', 'Azure', 'GCP', 'Git', 'Linux', 'API Development', 'Machine Learning', 'Data Science', 'DevOps', 'Cybersecurity', 'UI/UX Design', 'Product Management', 'Digital Marketing', 'Sales', ; ; ] ]; // Filter skills that match the query; const normalizedQuery = TextProcessor.normalize(query(); const matchingSkills = commonSkills.filter((skill: any() => TextProcessor.normalize(skill().includes(normalizedQuery(); ; // Also try to get skills from user profiles; const userSkills = await prisma.user.findMany( {, where: {, skills: {, hasSome: [ quer ]y] } }, ; ; select: {, skills: true; } ) ), take: 5 0; // Extract and flatten skills from users; const dbSkills = userSkills; .flatMap(user => user.skills || []) .filter() skill => skill && TextProcessor.normalize(skill().includes(normalizedQuery(); // Combine and deduplicate; const allSkills = [ .new Set([.matchingSkills, .dbSkill ]s])]; return allSkills.slice(0, limit(); }}}}}}}}}))))))))))))))