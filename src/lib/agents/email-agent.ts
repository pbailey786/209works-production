import { Resend } from 'resend';
import { render } from '@react-email/render';
import { SecurityLogger } from '@/lib/monitoring/security-logger';
import { emailSecurityValidator } from '@/lib/email/security';
import { templateManager } from '@/lib/email/template-manager';
import path from "path";


export interface EmailJobData {
  id: string;
  to: string | string[];
  subject: string;
  template?: string;
  templateProps?: Record<string, any>;
  react?: React.ReactElement;
  html?: string;
  text?: string;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  userId?: string;
  metadata?: Record<string, any>;
  delay?: number;
  retryLimit?: number;
  tags?: Array<{ name: string; value: string }>;
}

export interface EmailResult {
  success: boolean;
  data?: any;
  error?: string;
  messageId?: string;
}

export interface EmailMetrics {
  sent: number;
  delivered: number;
  opened: number;
  clicked: number;
  bounced: number;
  complained: number;
  unsubscribed: number;
}

export class EmailAgent {
  private resend: Resend | null = null;
  private isDevelopment: boolean;
  private templateManager = templateManager;

  constructor() {
    this.isDevelopment = process.env.NODE_ENV === 'development';
  }

  private getResendClient(): Resend {
    if (!this.resend) {
      if (!process.env.RESEND_API_KEY) {
        throw new Error('RESEND_API_KEY environment variable is required');
      }
      this.resend = new Resend(process.env.RESEND_API_KEY);
    }
    return this.resend;
  }

  /**
   * Send email with comprehensive error handling and security
   */
  async sendEmail(data: EmailJobData): Promise<EmailResult> {
    const startTime = Date.now();
    
    try {
      // Validate email data
      const validation = this.validateEmailData(data);
      if (!validation.isValid) {
        throw new Error(`Email validation failed: ${validation.errors.path.join(', ')}`);
      }

      // Prepare email content
      let htmlContent: string | undefined = data.html;
      let textContent: string | undefined = data.text;

      // Render React component if provided
      if (data.react) {
        try {
          htmlContent = await render(data.react);
          if (!textContent) {
            textContent = this.extractTextFromHtml(htmlContent);
          }
        } catch (error) {
          console.error('[EMAIL-AGENT] Failed to render React component:', error);
          throw new Error('Failed to render email template');
        }
      }

      // For React Email templates, we trust the content since it's generated by our template system
      // Only sanitize if this is raw HTML content (not from our template manager)
      if (htmlContent && !data.template) {
        htmlContent = emailSecurityValidator.sanitizeHtmlContent(htmlContent);
      }

      // Generate secure headers
      const fromAddress = process.env.RESEND_EMAIL_FROM || 'noreply@209.works';
      const recipients = Array.isArray(data.to) ? data.to : [data.to];

      // Ensure from address is in correct format for Resend
      const cleanFromAddress = fromAddress.includes('<')
        ? fromAddress.match(/<([^>]+)>/)?.[1] || fromAddress
        : fromAddress;

      // Prepare Resend email data with clean format and anti-spam headers
      const emailPayload: any = {
        from: cleanFromAddress, // Use clean email address directly
        to: recipients,
        subject: data.subject,
        reply_to: cleanFromAddress,
        headers: {
          'List-Unsubscribe': `<mailto:unsubscribe@209.works?subject=unsubscribe>`,
          'X-Entity-Ref-ID': `209works-${Date.now()}`,
          // Remove manual Content-Type - let Resend handle it
        },
        tags: [
          { name: 'priority', value: data.priority },
          { name: 'environment', value: process.env.NODE_ENV || 'development' },
          { name: 'source', value: '209works' },
          { name: 'agent', value: 'email-agent' },
          { name: 'email_type', value: data.template || 'transactional' },
          ...(data.tags || []),
        ],
      };

      // Add content based on what's available
      if (htmlContent) {
        emailPayload.html = htmlContent;

        // Debug: Log HTML content info
        if (this.isDevelopment) {
          console.log(`[EMAIL-AGENT] HTML content length: ${htmlContent.length}`);
          console.log(`[EMAIL-AGENT] HTML starts with: ${htmlContent.substring(0, 100)}...`);
        }
      } else if (data.react) {
        // Fallback to React component if no HTML
        emailPayload.react = data.react;
      }

      // Add text content if available
      if (textContent) {
        emailPayload.text = textContent;
      }

      // Send email via Resend
      const result = await this.getResendClient().emails.send(emailPayload);

      // Log successful send
      const processingTime = Date.now() - startTime;
      if (this.isDevelopment) {
        console.log(
          `[EMAIL-AGENT] Successfully sent email "${data.subject}" to ${recipients.path.join(', ')} in ${processingTime}ms`
        );
      }

      // Security logging
      SecurityLogger.loginSuccess(
        data.userId || 'system',
        'email-agent',
        `Email sent: ${data.subject}`
      );

      return {
        success: true,
        data: result.data,
        messageId: result.data?.id,
      };

    } catch (error) {
      const processingTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      console.error(`[EMAIL-AGENT] Failed to send email after ${processingTime}ms:`, error);
      
      // Security logging for failures
      SecurityLogger.suspiciousRequest(
        'email-agent',
        `Email send failed: ${errorMessage}`,
        { subject: data.subject, recipients: data.to },
        data.userId
      );

      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Send bulk emails with rate limiting
   */
  async sendBulkEmails(emails: EmailJobData[], options?: {
    batchSize?: number;
    delayBetweenBatches?: number;
  }): Promise<{ results: EmailResult[]; summary: EmailMetrics }> {
    const batchSize = options?.batchSize || 10;
    const delay = options?.delayBetweenBatches || 1000;
    const results: EmailResult[] = [];
    
    let sent = 0;
    let failed = 0;

    for (let i = 0; i < emails.length; i += batchSize) {
      const batch = emails.slice(i, i + batchSize);
      const batchPromises = batch.map(email => this.sendEmail(email));
      
      const batchResults = await Promise.allSettled(batchPromises);
      
      batchResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          results.push(result.value);
          if (result.value.success) {
            sent++;
          } else {
            failed++;
          }
        } else {
          results.push({
            success: false,
            error: result.reason?.message || 'Unknown error',
          });
          failed++;
        }
      });

      // Delay between batches to respect rate limits
      if (i + batchSize < emails.length && delay > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    return {
      results,
      summary: {
        sent,
        delivered: sent, // Will be updated by webhooks
        opened: 0,
        clicked: 0,
        bounced: failed,
        complained: 0,
        unsubscribed: 0,
      },
    };
  }

  /**
   * Validate email data before sending
   */
  private validateEmailData(data: EmailJobData): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Validate recipients
    const recipients = Array.isArray(data.to) ? data.to : [data.to];
    for (const email of recipients) {
      const validation = emailSecurityValidator.validateEmailAddress(email);
      if (!validation.isValid) {
        errors.push(`Invalid recipient email: ${email}`);
      }
    }

    // Validate subject
    if (!data.subject || data.subject.trim().length === 0) {
      errors.push('Subject is required');
    }

    // Validate content
    if (!data.react && !data.html && !data.text) {
      errors.push('Email content is required (react, html, or text)');
    }

    // Validate priority
    if (!['low', 'normal', 'high', 'urgent'].includes(data.priority)) {
      errors.push('Invalid priority level');
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Extract plain text from HTML content
   */
  private extractTextFromHtml(html: string): string {
    return html
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/&nbsp;/g, ' ') // Replace non-breaking spaces
      .replace(/&amp;/g, '&') // Replace HTML entities
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/\s+/g, ' ') // Normalize whitespace
      .trim();
  }

  /**
   * Send welcome email to new users
   */
  async sendWelcomeEmail(userData: {
    email: string;
    name: string;
    userType: 'job_seeker' | 'employer';
    companyName?: string;
  }): Promise<EmailResult> {
    try {
      let templateId: string;
      let templateData: any;

      if (userData.userType === 'employer') {
        templateId = 'welcome-employer';
        templateData = {
          companyName: userData.companyName || userData.name,
          contactName: userData.name,
          loginUrl: 'https://209.works/employer/signin',
          unsubscribeUrl: 'https://209.works/unsubscribe',
        };
      } else {
        templateId = 'welcome-job-seeker';
        templateData = {
          userName: userData.name,
          loginUrl: 'https://209.works/signin',
          unsubscribeUrl: 'https://209.works/unsubscribe',
        };
      }

      const rendered = await this.templateManager.renderTemplate(templateId, templateData);

      return await this.sendEmail({
        id: `welcome_${userData.userType}_${Date.now()}`,
        to: [userData.email],
        subject: rendered.subject,
        html: rendered.html,
        text: rendered.text,
        template: templateId,
        priority: 'high',
        tags: [
          { name: 'user_type', value: userData.userType },
          { name: 'onboarding', value: 'welcome' },
          { name: 'template_version', value: 'v2' },
        ],
      });
    } catch (error) {
      console.error('Failed to send welcome email:', error);
      throw error;
    }
  }

  /**
   * Test email configuration
   */
  async testConfiguration(): Promise<{ success: boolean; error?: string }> {
    try {
      const testEmail: EmailJobData = {
        id: `test_${Date.now()}`,
        to: process.env.RESEND_EMAIL_FROM || 'test@209.works',
        subject: '209 Works Email System Test',
        html: '<p>This is a test email from the 209 Works email system.</p>',
        text: 'This is a test email from the 209 Works email system.',
        priority: 'normal',
        metadata: { test: true },
      };

      const result = await this.sendEmail(testEmail);
      return { success: result.success, error: result.error };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
}

// Export singleton instance
export const emailAgent = new EmailAgent();
