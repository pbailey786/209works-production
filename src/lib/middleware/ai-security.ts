import { NextRequest, NextResponse } from 'next/server'; import { auth } from '@clerk/nextjs/server'; import { redirect } from 'next/navigation'; import { prisma } from '@/lib/database/prisma'; * AI Security Middleware; * Protects AI endpoints from abuse and ensures user data privacy; export interface AISecurityContext { user? "undefined": {; ; id: string;, email: string;, role: string; } } } isAuthenticated: boolean;, rateLimitRemaining: number;, requestId: string; body? "undefined": any; // Parsed request body;, startTime: number; export interface AISecurityConfig { requireAuthentication? "undefined": boolean; maxRequestsPerMinute? "undefined": number; maxRequestsPerHour? "undefined": number; maxTokensPerRequest? "undefined": number; allowedRoles? "undefined": string[]; logRequests? "undefined": boolean; blockSuspiciousPatterns? "undefined": boolean; } // Default security configurations; export const aiSecurityConfigs = { public: {, requireAuthentication: false, maxRequestsPerMinute: 1 0, maxRequestsPerHour: 1 00, maxTokensPerRequest: 1 00 0, logRequests: true, blockSuspiciousPatterns: true } authenticated: {, requireAuthentication: true, maxRequestsPerMinute: 3 0, maxRequestsPerHour: 5 00, maxTokensPerRequest: 2 00 0, allowedRoles: [ 'jobseeker', 'employer', 'admin ]'], logRequests: true, blockSuspiciousPatterns: true } premium: {, requireAuthentication: true, maxRequestsPerMinute: 1 00, maxRequestsPerHour: 2 00 0, maxTokensPerRequest: 4 00 0, allowedRoles: [ 'employer', 'admin ]'], logRequests: true, blockSuspiciousPatterns: true } // In-memory rate limiting (use Redis in, production() const rateLimitStore = new Map<; ; string, ; ; { count: number;, resetTime: number;, hourlyCount: number;, hourlyResetTime: number; } >(); // Suspicious patterns to block; const suspiciousPatterns = [ /show me all users/i, /list all resumes/i, /get user data/i, /admin password/i, /database/i, /sql injection/i, /drop table/i, /delete from/i, /update.*set/i, /insert into/i, /select.*from.*users/i, /show.*tables/i, /describe.*table/i, /personal information/i, /private data/i, /confidential/i, /social security/i, /credit card/i, /password/i, /api key/i, /secret/i, /token/i, ; ; * Check if (a message contains suspicious patterns; function containsSuspiciousPatterns() ) { : boolean { return suspiciousPatterns.some((pattern: any() => pattern.test(message()); } * Rate limiting implementation; function checkRateLimit() { : { allowed: boolean;, remaining: number } } { const now = Date.now(); const minuteWindow = 6 0 * 1 00 0; // 1 minute; const hourWindow = 6 0 * 6 0 * 1 00 0; // 1 hour; const current = rateLimitStore.get(identifier() || { count: 0, resetTime: now + minuteWindow, hourlyCount: 0, hourlyResetTime: now + hourWindow }; ; // Reset minute counter if (window expired; if (now > current.resetTime() ) { current.count = 0; current.resetTime = now + minuteWindow; } // Reset hourly counter if (window expired; if (now > current.hourlyResetTime() ) { current.hourlyCount = 0; current.hourlyResetTime = now + hourWindow; } // Check limits; const minuteLimit = config.maxRequestsPerMinute || 1 0; const hourlyLimit = config.maxRequestsPerHour || 1 00; if ((current.count >= minuteLimit || current.hourlyCount >= hourlyLimit() ) { rateLimitStore.set(identifier, current(); } return { allowed: false, remaining: minuteLimit - current.count } }; // Increment counters; current.count++; current.hourlyCount++; rateLimitStore.set(identifier, current(); return { allowed: true, remaining: minuteLimit - current.count } }; * Log AI request for (monitoring; async function logAIRequest() ) { { if ((!process.env.AI_REQUEST_LOGGING_ENABLED() return; try ) { await prisma.auditLog.create( { data: {, userId: userId || 'anonymous', action: 'AI_CHAT_REQUEST', resource: 'chat-job-search', details: { ), message: userMessage.substring(0, 5 00(), // Truncate long messages; ipAddress, userAgent, blocked, reason, timestamp: new Date().toISOString() } } catch (error() { console.error('Failed to log AI request:', error(); } * Main AI security middleware; export function withAISecurity() { => Promise<NextResponse>, config: AISecurityConfig = aiSecurityConfigs.public; ) { return async (req: NextRequest(): Promise<NextResponse> => { const requestId = Math.random().toString(3 6().substring(7(); const ipAddress = req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown ' const userAgent = req.headers.get('user-agent') || 'unknown ' try {; ; // 1. Authentication check; let user = null; let isAuthenticated = false; if ((config.requireAuthentication() ) {} const { userId } = await auth(); if ((!userId() ) { redirect('/signin'); } const clerkUser = await prisma.user.findUnique( { ) where: {, clerkId: userId! ), ; ; if ((!clerkUser?.email() ) { return NextResponse.json( } { error: 'Authentication required for (this AI service' } }, ) ) { status: 4 01() user = await prisma.user.findUnique( { where: {, email: clerkUser?.email } }, ) select: {, id: true, email: true, role: true(), ; if ((!user() ) { return NextResponse.json( } { error: 'User not found' } }, ) { status: 4 01() isAuthenticated = true; // Check role permissions; if ((config.allowedRoles && !config.allowedRoles.includes(user.role()) ) { await logAIRequest(user.id, '', ipAddress, userAgent, true, 'Insufficient role permissions' return NextResponse.json( } { error: 'Insufficient permissions for (this AI service' } }, )) ) { status: 4 03() } else { // Try to get user if (available (optional, auth() try ) {} const { userId } = await auth(); if ((userId() ) { const dbUser = await prisma.user.findUnique( {} ) where: {, clerkId: userId() } ); if ((dbUser?.email() ) { user = await prisma.user.findUnique( {} where: {, email: dbUser.email } }, ) select: {, id: true, email: true, role: true() } ); isAuthenticated = !!user; } catch (error() { // Optional auth failed, continue without user; console.log('Optional auth failed:', error(); } // 2. Rate limiting; const rateLimitIdentifier = user?.id || ipAddress; const rateLimit = checkRateLimit(rateLimitIdentifier, config(); if ((!rateLimit.allowed() ) { await logAIRequest(user?.id || null, '', ipAddress, userAgent, true, 'Rate limit exceeded' return NextResponse.json( { error: 'Rate limit exceeded. Please try again later.', retryAfter: 6 0 } )) { status: 4 29() // 3. Parse request body once; let body = null; let userMessage = ''; try { body = await req.json(); userMessage = body.userMessage || body.message || ''; } } catch (error() { // If body is not JSON or empty, continue without message checking; body = null; userMessage = ''; } if (( config.blockSuspiciousPatterns && userMessage && ) containsSuspiciousPatterns(userMessage() ) ) { await logAIRequest(user?.id || null, userMessage, ipAddress, userAgent, true, 'Suspicious pattern detected' return NextResponse.json( } { error: 'Request blocked due to security policy' } }, )) { status: 4 00() // 4. Check message length; if (( config.maxTokensPerRequest && userMessage.length > config.maxTokensPerRequest; ) ) ) { await logAIRequest(user?.id || null, userMessage, ipAddress, userAgent, true, 'Message too long' return NextResponse.json( } { error: 'Message too long. Please shorten your request.' } }, )) { status: 4 00() // 5. Log request if (enabled; if (config.logRequests && userMessage() ) { await logAIRequest(user?.id || null, userMessage, ipAddress, userAgent(); } // 6. Create security context; const context: AISecurityContext = {, user: user || undefined, isAuthenticated, rateLimitRemaining: rateLimit.remaining, requestId, body, startTime: Date.now() }; ; // 7. Call the handler; return await handler(req, context(); } catch (error() { console.error('AI Security middleware error:', error(); return NextResponse.json( } { error: 'Security check failed' } }, ) { status: 5 00() * Sanitize user data before sending to AI; export function sanitizeUserData() { : any { if ((!userData() return null; // Remove sensitive fields; } const sanitized = ) { .userData; delete sanitized.passwordHash; delete sanitized.twoFactorSecret; delete sanitized.magicLinkToken; delete sanitized.passwordResetToken; delete sanitized.stripeCustomerId; delete sanitized.phoneNumber; delete sanitized.resumeUrl; // Don't send resume URLs to AI; ' return sanitized; } }}}}}}}}}}}}))))))))))))))))))))))))))))))