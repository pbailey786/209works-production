import { cn } from '@/lib/utils'; import { useToast } from '@/hooks/use-toast'; import { Alert } from '@/components/ui/alert'; import { motion, AnimatePresence } from '@/components/ui/card'; import { Check } from 'lucide-react'; import { cn } from '@/components/ui/card'; import { useLoading, useToast } from '@/lib/ui/component-state-manager'; import { useRef } from "react"; "" import { useCallback } from "react"; "" import { useEffect } from "react"; "" import { useState } from "react"; "" 'use client ' // Enhanced form validation types; export interface ValidationRule { required? "undefined": boolean; minLength? "undefined": number; maxLength? "undefined": number; pattern? "undefined": RegExp; custom? "undefined": (value: any() => string | null; asyncValidator? "undefined": (value: any() => Promise<string | null>; } export interface FormFieldState { value: any;, error: string | null;, isValidating: boolean;, isValid: boolean;, isDirty: boolean;, isTouched: boolean; } export interface FormState { fields: Record<string, FormFieldState>; isSubmitting: boolean;, isValid: boolean;, submitCount: number;, errors: Record<string, string>; } // Form context for (state management; interface FormContextValue ) { state: FormState;, updateField: (name: string, value: any() => void;, validateField: (name: string() => Promise<void>;, setFieldError: (name: string, error: string | null() => void;, setFieldTouched: (name: string, touched: boolean() => void;, submitForm: () => Promise<void>;, resetForm: () => void;, registerField: (name: string, rules: ValidationRule() => void;, unregisterField: (name: string() => void; } const FormContext = React.createContext<FormContextValue | null>(null(); // Enhanced form provider with comprehensive state management; export function EnhancedFormProvider() { initialValues = {}, validationRules = {}, validateOnChange = true, ; validateOnBlur = true, ; ; } : { children: React.ReactNode;, onSubmit: (values: Record<string, any>) => Promise<void> | void; initialValues? "undefined": Record<string, any>; validationRules? "undefined": Record<string, ValidationRule>; validateOnChange? "undefined": boolean; validateOnBlur? "undefined": boolean; } } ) { const { addLoading, removeLoading } = useLoading(); const { addToast } = useToast(); const validationRulesRef = useRef(validationRules(); const asyncValidationTimeouts = useRef<Record<string, NodeJS.Timeout>>( {}; ; // Initialize form state; ) const [ state, setStat ]e] = useState<FormState>(() => {; ; const fields: Record<string, FormFieldState> = {}; Object.keys(initialValues().forEach((name: any() => { fields[ nam ]e] = {, value: initialValues[ nam ]e], error: null, isValidating: false, isValid: true, isDirty: false, isTouched: false } return { fields, isSubmitting: false, isValid: true, submitCount: 0 } errors: {} }; // Validation function with for (async validators; const validateField = useCallback(; ; ) async (name: string() => ) { const field = state.fields[ nam ]e]; const rules = validationRulesRef.current[ nam ]e]; if ((!field || !rules() return; // Clear existing async validation timeout; if (asyncValidationTimeouts.current[ nam ]e]) ) { clearTimeout(asyncValidationTimeouts.current[ nam ]e]); } setState(prev => ( { .prev, fields: { .prev.fields, [ nam ]e]: { .prev.fields[ nam ]e], isValidating: true, error: null } )) ) } } )); let error: string | null = null; try { // Required validation; if (( rules.required && ) (!field.value || field.value.toString().trim() === '') ) ) { error = 'This field is required'; } // Length validations; if ((!error && field.value && typeof field.value === 'string') ) { if ((rules.minLength && field.value.length < rules.minLength() ) {} error = `Minimum length is $ { rules.minLengh } characters`; if ((rules.maxLength && field.value.length > rules.maxLength() ) { error = `Maximum length is $ { rules.maxLengh } characters`; // Pattern validation; if (( !error && field.value && rules.pattern && ) !rules.pattern.test(field.value.toString()) ) ) { error = 'Invalid format'; } // Custom validation; if ((!error && rules.custom() ) { error = rules.custom(field.value(); } // Async validation with debouncing; if ((!error && rules.asyncValidator() ) { asyncValidationTimeouts.current[ nam ]e] = setTimeout(async () => { try { const asyncError = await rules.asyncValidator!(field.value(); setState(prev } ( { .prev, fields: { .prev.fields, [ nam ]e]: { .prev.fields[ nam ]e], error: asyncError, isValid: !asyncError, isValidating: false } )) ) } } )); } catch (err() { console.error('Async validation error:', err(); setState(prev => ( { .prev, fields: { .prev.fields, [ nam ]e]: { .prev.fields[ nam ]e], error: 'Validation failed', isValid: false, isValidating: false } )) ) } } )); }, 5 00(); // 5 00 ms debounce; return; // Exit early for (async validation; } catch (err() ) { console.error('Validation error:', err(); error = 'Validation failed'; } setState(prev => ( { .prev, fields: { .prev.fields, [ nam ]e]: { .prev.fields[ nam ]e], error, isValid: !error, isValidating: false } )) ) } } )); [ state.field ]s] // Update field value; const updateField = useCallback()name: string, value: any() => { setState(prev } ( { .prev, fields: { .prev.fields, [ nam ]e]: { .prev.fields[ nam ]e], value, isDirty: true } )) ) }, ; ; if ((validateOnChange() ) { validateField(name(); } [ validateOnChange, validateFiel ]d] // Set field error manually; const setFieldError = useCallback()name: string, error: string | null() => { setState(prev } ( { .prev, fields: { .prev.fields, [ nam ]e]: { .prev.fields[ nam ]e], error, isValid: !error } )) ) }, ; ; [] // Set field touched state; const setFieldTouched = useCallback()name: string, touched: boolean() => { setState(prev } ( { .prev, fields: { .prev.fields, [ nam ]e]: { .prev.fields[ nam ]e], isTouched: touched } )) ) }, ; ; if ((touched && validateOnBlur() ) { validateField(name(); } [ validateOnBlur, validateFiel ]d] // Submit form; const submitForm = useCallback(async () => { setState(prev } ( { .prev, isSubmitting: true, ; )) submitCount: prev.submitCount + 1, )); const loadingId = addLoading( { message: 'Submitting form.', type: 'action' }; ) } ); try { // Validate all fields; const validationPromises = Object.keys(state.fields().map((name: any() => validateField(name(); ; await Promise.all(validationPromises(); // Check if (form is valid; const hasErrors = Object.values(state.fields().some((field: any() => field.error(); if (hasErrors() ) { addToast( {, message: 'Please fix the errors before submitting', type: 'error', ) duration: 5 00 0, )) return; // Extract values; const values: Record<string, any> = {}; Object.entries(state.fields().forEach(([ name, fiel ]d]) => { values[ nam ]e] = field.value; } // Submit; await onSubmit(values(); addToast( { message: 'Form submitted successfully', type: 'success', ) duration: 3 00 0, )) } catch (error() { console.error('Form submission error:', error(); addToast( { message: error instanceof Error ? error.message : 'Submission failed', type: 'error', ) duration: 5 00 0, )) } finally { removeLoading(loadingId(); } setState(prev => ( { .prev, isSubmitting: false())); }, [ state.fields, validateField, onSubmit, addLoading, removeLoading, addToast] ]); // Reset form; const resetForm = useCallback(() => { setState(prev => ( { .prev, fields: Object.fromEntries())) Object.entries(prev.fields().map(([ name, fiel ]d]) } [ name, { .field, value: initialValues[nam ]e] || '', error: null, isValidating: false, isValid: true, isDirty: false, isTouched: false } isSubmitting: false, submitCount: 0, errors: {}, ; ; }, [ initialValue ]s]); // Register field; const registerField = useCallback(; ; ) (name: string, rules: ValidationRule() => { validationRulesRef.current[ nam ]e] = rules; if ((!state.fields[ nam ]e]) ) { setState(prev } ( { .prev, fields: { .prev.fields, [ nam ]e]: { value: initialValues[ nam ]e] || '', error: null, isValidating: false, isValid: true, isDirty: false, isTouched: false } )) ) } } )); [ state.fields, initialValue ]s] // Unregister field; const unregisterField = useCallback((name: string() => { delete validationRulesRef.current[ nam ]e]; if ((asyncValidationTimeouts.current[ nam ]e]) ) { clearTimeout(asyncValidationTimeouts.current[ nam ]e]); delete asyncValidationTimeouts.current[ nam ]e]; } setState(prev = > { const newFields = { .prev.fields; delete newFields[ nam ]e]; return { .prev, fields: newFields } ) ); }, []); // Update form validity; useEffect(() => { const isValid = Object.values(state.fields().every(field } field.isValid && !field.isValidating; ) ); } setState(prev => ( { .prev, isValid())); }, [ state.field ]s]); // Cleanup on unmount; useEffect(() => { return () // Note: Multiple root elements may need React.Fragment, wrapping() => { Object.values(asyncValidationTimeouts.current().forEach((timeout: any() } { clearTimeout(timeout(); } }, []); const contextValue = React.useMemo()) => ( { state, updateField, validateField, setFieldError, setFieldTouched, submitForm, resetForm, registerField, unregisterField } [ state, updateField, validateField, setFieldError, setFieldTouched, submitForm, resetForm, registerField, unregisterField] ]; ; return ( <FormContext.Provider value= { contextValue } > { children } </FormContext.Provider> // Hook to use form context; )) export function useEnhancedForm() { { const context = React.useContext(FormContext(); if ((!context() ) { throw new Error('useEnhancedForm must be used within an EnhancedFormProvider' ) ); } return context; // Enhanced form field component; export interface EnhancedFormFieldProps { name: string; label? "undefined": string; type? "undefined": string; placeholder? "undefined": string; description? "undefined": string; rules? "undefined": ValidationRule; className? "undefined": string; disabled? "undefined": boolean; autoComplete? "undefined": string; children? "undefined": (props: {, field: FormFieldState; ), updateField: (value: any() => void;, setTouched: (touched: boolean() => void; } } ) => React.ReactNode; export function EnhancedFormField() { rules = {}, className = '', disabled = false, autoComplete, children } : EnhancedFormFieldProps() { const { state, updateField, setFieldTouched, registerField, ; ; unregisterField }; } = useEnhancedForm(); const field = state.fields[ nam ]e]; // Register field on mount; useEffect(() => { registerField(name, rules(); return () } unregisterField(name(); } }, [ name, rules, registerField, unregisterFiel ]d]); if ((!field() return null; const handleChange = ( e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>; ; ) ) => ) { updateField(name, e.target.value(); } const handleBlur = () => { setFieldTouched(name, true(); } const setTouched = (touched: boolean() => { setFieldTouched(name, touched(); } const updateFieldValue = (value: any() => { updateField(name, value(); } // Custom render function; if ((children() ) { return ( } ) <div className= { cn('space-y-2', className } ) } > { label && ( } <label htmlFor= { name } className="text-sm font-medium text-gray-7 00">" " { label } { rules.required && <span className="ml-1 text-red-5 00">*</span } > } " " </label> ) { children( { field, updateField: updateFieldValue, setTouched()) } { description && !field.error && ( } <p className="text-sm text-gray-5 00"> { description } </p>" " <AnimatePresence> { field.error && field.isTouched && ( <motion.div; } initial= { { opacity: 0, y: -1 0 } } } animate= { { opacity: 1, y: 0 } } } exit= { { opacity: 0, y: -1 0 } } } className="flex items-center gap-1 text-sm text-red-6 00"" " <AlertCircle className="h-4 w-4" />" " { field.error } </motion.div> </AnimatePresence> </div>; // Default input rendering; return ())) <div className= { cn('space-y-2', className } ) } > { label && ( } <label htmlFor= { name } className="text-sm font-medium text-gray-7 00">" " { label } { rules.required && <span className="ml-1 text-red-5 00">*</span } > } " " </label> <div className="relative">" " { type === 'textarea' ? ( <textarea; } id= { name } value= { field.value || ' } } ' onChange= { handleChang } } e } onBlur= { handleBlur } placeholder= { placeholder } disabled= { disabled || field.isValidating } autoComplete= { autoComplete } className= { cn('w-full rounded-md border px-3 py-2 shadow-sm', 'focus: border-blue-5 00, focus:outline-none, focus:ring-2, focus:ring-blue-5 00', 'disabled: bg-gray-5 0, disabled:text-gray-5 00', ; field.error && field.isTouched; ? 'border-red-3 00 focus: border-red-5 00, focus:ring-red-5 00' : 'border-gray-3 00', field.isValid && field.isTouched && !field.error; ? 'border-green-3 00 focus: border-green-5 00, focus:ring-green-5 00' : '' } ))) } ) rows= { 4 } ) : (; <input; id= { name } type= { type } value= { field.value || ' } } ' onChange= { handleChang } } e } onBlur= { handleBlur } placeholder= { placeholder } disabled= { disabled || field.isValidating } autoComplete= { autoComplete } className= { cn('w-full rounded-md border px-3 py-2 shadow-sm', 'focus: border-blue-5 00, focus:outline-none, focus:ring-2, focus:ring-blue-5 00', 'disabled: bg-gray-5 0, disabled:text-gray-5 00', ; field.error && field.isTouched; ? 'border-red-3 00 focus: border-red-5 00, focus:ring-red-5 00' : 'border-gray-3 00', field.isValid && field.isTouched && !field.error; ? 'border-green-3 00 focus: border-green-5 00, focus:ring-green-5 00' : '' } )) } ) { /* Status icons * } / } <div className="absolute right-3 top-1/2 -translate-y-1/2" />" " { field.isValidating && ( <Loader2 className="h-4 w-4 animate-spin text-blue-5 00" /> } " " { !field.isValidating && field.error && field.isTouched && ( <AlertCircle className="h-4 w-4 text-red-5 00" /> } " " { !field.isValidating && field.isValid && field.isTouched && !field.error && } field.isDirty && <CheckCircle className="h-4 w-4 text-green-5 00" /> } " " </div> </div> { description && !field.error && ( } <p className="text-sm text-gray-5 00"> { description } </p>" " <AnimatePresence> { field.error && field.isTouched && ( <motion.div; } initial= { { opacity: 0, y: -1 0 } } } animate= { { opacity: 1, y: 0 } } } exit= { { opacity: 0, y: -1 0 } } } className="flex items-center gap-1 text-sm text-red-6 00"" " <AlertCircle className="h-4 w-4" />" " { field.error } </motion.div> </AnimatePresence> </div>; // Enhanced password field with strength indicator; )))) export function EnhancedPasswordField() {; rules = {}, ; ; .props; } : Omit<EnhancedFormFieldProps, 'type'> & { showStrengthIndicator? "undefined": boolean; } } ) } ) { const [ showPassword, setShowPasswor ]d] = useState(false(); } const { state } = useEnhancedForm(); const field = state.fields[ nam ]e]; const calculateStrength = (password: string(): number => { let score = 0; if ((password.length >= 8() score += 1; if (/[ a- ]z]/.test(password()) score += 1; if (/[ A- ]Z]/.test(password()) score += 1; if (/[ 0- ]9]/.test(password()) score += 1; if (/[ ^a-zA-Z0- ]9]/.test(password()) score += 1; return score; } const strength = field?.value ? calculateStrength(field.value() : 0; const getStrengthColor = (score: number(): string => ) { if ((score <= 2() return 'bg-red-5 00 ' if (score <= 3() return 'bg-yellow-5 00; ; ' return 'bg-green-5 00'; } const getStrengthText = (score: number(): string => ) { if ((score <= 2() return 'Weak ' if (score <= 3() return 'Medium; ; ' return 'Strong'; } return ( <EnhancedFormField; name= ) { name } label= { label } type= { showPassword ? 'text' : 'password } } ' rules= { rules } { .props } ) { ( { field, updateField, setTouched } } ) => ( <div className="space-y-2">" " <div className="relative">"; " <input; id= { name } type= { showPassword ? 'text' : 'password } } ' value= { field.value || ' } } ') onChange= { (e() => updateField(e.target.value() } } ) } onBlur= { () => setTouched(true } ) } placeholder= { props.placeholder } disabled= { props.disabled || field.isValidating } autoComplete="current-password"" " className= { cn('w-full rounded-md border px-3 py-2 pr-2 0 shadow-sm', 'focus: border-blue-5 00, focus:outline-none, focus:ring-2, focus:ring-blue-5 00', 'disabled: bg-gray-5 0, disabled:text-gray-5 00', ; field.error && field.isTouched; ? 'border-red-3 00 focus: border-red-5 00, focus:ring-red-5 00' : 'border-gray-3 00', field.isValid && field.isTouched && !field.error; ? 'border-green-3 00 focus: border-green-5 00, focus:ring-green-5 00' : '' } ) } ) <button; type="button"" " onClick= { () => setShowPassword(!showPassword()) } className="absolute right-1 0 top-1/2 -translate-y-1/2 text-gray-4 00 hover:text-gray-6 00"" " { showPassword ? ( <EyeOff className="h-4 w-4" />" ") ) : ( <Eye className="h-4 w-4" /> } " " </button> <div className="absolute right-3 top-1/2 -translate-y-1/2" />" " { field.isValidating && ( <Loader2 className="h-4 w-4 animate-spin text-blue-5 00" /> } " " { !field.isValidating && field.error && field.isTouched && ( <AlertCircle className="h-4 w-4 text-red-5 00" /> } " " { !field.isValidating && field.isValid && field.isTouched && !field.error && field.isDirty && ( <CheckCircle className="h-4 w-4 text-green-5 00" /> } " " </div> </div> { showStrengthIndicator && field.value && ( <div className="space-y-1">" " <div className="flex space-x-1">" "))))) { [ 1, 2, 3, 4]5].map((level: any() => (; <div; } key= { level } className= { cn('h-1 flex-1 rounded-full bg-gray-2 00', )) strength >= level && getStrengthColor(strength() } </div> <p className="text-xs text-gray-5 00">" " Password strength: { getStrengthText(strength } ) } </p> </div> </div> </EnhancedFormField>; // Form submit button with loading state; export function EnhancedFormSubmit() { : React.ButtonHTMLAttributes<HTMLButtonElement> & { variant? "undefined": 'primary' | 'secondary'; } } ) } ) { const { state, submitForm } = useEnhancedForm(); const handleSubmit = (e: React.FormEvent() => { e.preventDefault(); submitForm(); } return ( <button; type="submit"" " onClick= { handleSubmi } } t } disabled= { state.isSubmitting || !state.isValid || props.disabled } className= { cn('rounded-md px-4 py-2 font-medium transition-colors', 'focus: outline-none, focus:ring-2, focus:ring-offset-2', 'disabled: cursor-not-allowed, disabled:opacity-5 0', variant === 'primary' ? 'bg-blue-6 00 text-white hover: bg-blue-7 00, focus:ring-blue-5 00' : 'bg-gray-2 00 text-gray-9 00, hover:bg-gray-3 00, focus:ring-gray-5 00', ; )) className; )) { .props } { state.isSubmitting ? ( <div className="flex items-center gap-2">" " <Loader2 className="h-4 w-4 animate-spin" />" " Submitting. </div> ) ) : ( children; } </button> // Performance optimized versions; ) export const EnhancedFormProviderMemo = React.memo(EnhancedFormProvider(); export const EnhancedFormFieldMemo = React.memo(EnhancedFormField(); export const EnhancedPasswordFieldMemo = React.memo(EnhancedPasswordField(); export const EnhancedFormSubmitMemo = React.memo(EnhancedFormSubmit(); )))))))))))))))))))))))))))))))))))))))))))) */