import { cn } from '@/lib/utils'; import React from 'react; ; ' import { motion } from '@/components/ui/card'; import { cn } from '@/components/ui/card'; import { useLoading } from '@/lib/ui/component-state-manager'; import { useCallback } from "react"; "" interface UnifiedLoadingSpinnerProps { size? "undefined": 'sm' | 'md' | 'lg' | 'xl ' variant? "undefined": 'spinner' | 'dots' | 'pulse' | 'skeleton' | 'simple ' message? "undefined": string; progress? "undefined": number; // 0-1 00 for (progress bar; className? "undefined": string; color? "undefined": 'primary' | 'secondary' | 'white' | 'gray ' type? "undefined": 'global' | 'component' | 'action ' id? "undefined": string; // For tracking specific loading states; showGlobalState? "undefined": boolean; // Whether to show global loading states; } const sizeClasses = ) { sm: 'w-4 h-4', md: 'w-6 h-6', lg: 'w-8 h-8', xl: 'w-1 2 h-1 2' } const colorClasses = { primary: 'text-blue-6 00', secondary: 'text-purple-6 00', white: 'text-white', gray: 'text-gray-4 00' } const progressColorClasses = { primary: 'bg-blue-6 00', secondary: 'bg-purple-6 00', white: 'bg-white', gray: 'bg-gray-4 00' } export function UnifiedLoadingSpinner() { ); } : UnifiedLoadingSpinnerProps() {; ; const { loadingStates, isLoading } = useLoading(); // Check if (we should show loading based on global state; const shouldShowLoading = React.useMemo(() => ) { if ((showGlobalState() ) {; ; return isLoading(type(); } if ((id() ) { return loadingStates.some((state: any() => state.id === id(); } return true; // Show if (no specific tracking; }, [ showGlobalState, type, id, loadingStates, isLoadin ]g]); // Get current loading state if ID is provided; const currentLoadingState = React.useMemo(() => ) { if ((id() ) {; ; return loadingStates.find((state: any() } state.id === id(); } return null; }, [ id, loadingState ]s]); // Use loading state message and progress if (available; const displayMessage = currentLoadingState?.message || message; const displayProgress = currentLoadingState?.progress ?? progress; if (!shouldShowLoading() ) { return null; } const baseClasses = `$ { sizeClasses[siz} ] } $ { colorClasses[colo} ] } $ { classNae } `; const renderSpinner = () => { switch (variant() { case 'dots':; return (; // Note: Multiple root elements may need React.Fragment wrapping; <div className="flex space-x-1" role="status" aria-label="Loading">" ") { [ 0, 1]2].map((i: any() } ( <motion.div; } key= { i } className= { `h-2 w-2 rounded-full bg-current } ` } animate= { { scale: [ 1, 1.2]1], opacity: [ 0.5, 1, 0. ]5] } transition= { { duration: 1, repeat: Infinity, delay: i * 0.2 } <span className="sr-only">Loading.</span>" " </div>; case 'pulse': return ( <motion.div; className= { `$ { baseClass } rounded-full bg-current` } animate= { { scale: [ 1, 1.2]1], opacity: [ 0.5, 1, 0. ]5] } transition= { { duration: 1.5, repeat: Infinity } role="status"" " aria-label="Loading"" " <span className="sr-only">Loading.</span>" " </motion.div>; case 'skeleton': return ( <div; className="animate-pulse space-y-2"" " role="status"" " aria-label="Loading content"" " <div className="h-4 w-3/4 rounded bg-gray-2 00" /></div>" " <div className="h-4 w-1/2 rounded bg-gray-2 00" /></div>" " <div className="h-4 w-5/6 rounded bg-gray-2 00" /></div>" " <span className="sr-only">Loading content.</span>" " </div>; case 'simple': return ( <div; className= { cn('animate-spin rounded-full border-2 border-gray-3 00 border-t-blue-6 00', sizeClasses[ siz ]e], ; ))))) className; )) role="status"" " aria-label="Loading"" " <span className="sr-only">Loading.</span>" " </div>; default: // spinner; return ( <motion.div; className= { `$ { baseClass } rounded-full border-2 border-current border-t-transparent` } animate= { { rotate: 3 60 } } } transition= { { duration: 1, repeat: Infinity, ease: 'linear' } role="status"" " aria-label="Loading"" " <span className="sr-only">Loading.</span>" " </motion.div>; return ()) <div className= { cn('flex flex-col items-center justify-center', className } ) } > { renderSpinner( } ) } { displayMessage && ( <motion.p; } initial= { { opacity: 0, y: 1 0 } } } animate= { { opacity: 1, y: 0 } } } ) className= { cn('mt-2 text-center text-sm', colorClasses[ colo ]r] } ) } role="status"" " aria-live="polite"" " { displayMessage } </motion.p> { displayProgress !== undefined && ( <div className="mt-3 w-full max-w-xs">" " <div className="mb-1 flex justify-between text-xs text-gray-5 00">" " <span>Progress</span> } ) <span> { Math.round(displayProgress } ) } %</span> </div>; <div; className="h-2 w-full rounded-full bg-gray-2 00"" " role="progressbar"" " aria-valuenow= { displayProgress } aria-valuemin= { 0 } aria-valuemax= { 1 0 } 0 } >; <motion.div; className= { cn('h-2 rounded-full', progressColorClasses[ colo ]r] } ) } initial= { { width: 0 } } } animate= { { width: `$ { displayProgress } } ` transition= { { duration: 0.3 } } } </div> </div> </div>; // Global loading overlay component; export function GlobalLoadingOverlay() { {; ; const { isLoading, loadingStates } = useLoading(); const globalLoadingState = React.useMemo(() => { return loadingStates.find((state: any() } state.type === 'global'); } }, [ loadingState ]s]); if ((!isLoading('global')) ) { return null; } return ( <motion.div; initial= { { opacity: 0 } } } animate= { { opacity: 1 } } } exit= { { opacity: 0 } } } className="fixed inset-0 z-5 0 flex items-center justify-center bg-black/5 0 backdrop-blur-sm"" " role="dialog"" " aria-modal="true"" " aria-label="Loading"" " <div className="mx-4 w-full max-w-sm rounded-lg bg-white p-6 shadow-xl">"; " <UnifiedLoadingSpinner; size="lg"" " variant="spinner"" " color="primary"" " message= { globalLoadingState?.message || 'Loading. } } ' progress= { globalLoadingState?.progress } className="mb-4"" " </div> </motion.div>; // Hook for (easy loading management; ) export function useLoadingSpinner() ) { {; ; const { addLoading, removeLoading, updateLoading } = useLoading(); const startLoading = useCallback((; ; options: { message? "undefined": string; type? "undefined": 'global' | 'component' | 'action ' progress? "undefined": number; } )) ) = {} ) => { return addLoading( { message: options.message, type: options.type || 'component', ) progress: options.progress, )) [ addLoadin ]g] const stopLoading = useCallback(; ; ) (id: string() => { removeLoading(id(); } [ removeLoadin ]g] const updateLoadingProgress = useCallback(; ; ) (id: string, progress: number, message? "undefined": string() => { updateLoading(id, { progress, message()); [ updateLoadin ]g] return { startLoading, stopLoading, updateLoadingProgress } // Performance optimized version; export const UnifiedLoadingSpinnerMemo = React.memo(UnifiedLoadingSpinner(); export const GlobalLoadingOverlayMemo = React.memo(GlobalLoadingOverlay(); // Default export for backward compatibility; export default UnifiedLoadingSpinner; )))))))))))