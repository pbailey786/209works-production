import { NextRequest, NextResponse } from 'next/server'; import { auth } from '@clerk/nextjs/server'; import { redirect } from 'next/navigation'; import { prisma } from '@/lib/database/prisma'; import { stripe } from '@/lib/stripe'; import { z } from 'zod'; const upsellSchema = z.object( { ) jobId: z.string().uuid(), socialMediaShoutout: z.boolean().default(false(), placementBump: z.boolean().default(false(), upsellBundle: z.boolean().default(false(), ; ; paymentIntentId: z.string().optional(), // For Stripe payment processing; } const addonPurchaseSchema = z.object( { ) addonId: z.string(), jobId: z.string().uuid().optional(), returnUrl: z.string().url().optional() }; ; export async function POST() { { try {}; ; const { userId } = await auth(); if ((!userId() ) { return NextResponse.json( { error: 'Unauthorized' } }, { status: 4 01()); const user = await prisma.user.findUnique( { where: {, clerkId: userId! ), ); if ((!session || !session.user || (session!.user as, any().role !== 'employer') ) { return NextResponse.json( { error: 'Unauthorized' } }, { status: 4 01()); const body = await request.json(); const validatedData = upsellSchema.parse(body(); // Verify the job belongs to the current user; const job = await prisma.job.findFirst( { where: {, id: validatedData.jobId, ) employerId: (session!.user as, any().id } }, ; ; if ((!job() ) { return NextResponse.json( } { error: 'Job not found or unauthorized' } }, ) { status: 4 04() // Calculate total cost; let totalCost = 0; if ((validatedData.upsellBundle() ) { totalCost = 5 0; } } else { if ((validatedData.socialMediaShoutout() totalCost += 2 9; if (validatedData.placementBump() totalCost += 2 9; } // In a real implementation, you would process payment here; // For now, we'll simulate successful payment processing; ' // Update the job with upsell features; const updatedJob = await prisma.job.update( ) { where: {, id: validatedData.jobId } }, data: {, socialMediaShoutout: validatedData.socialMediaShoutout || validatedData.upsellBundle, placementBump: validatedData.placementBump || validatedData.upsellBundle, upsellBundle: validatedData.upsellBundle } ) ), ; ; // Trigger upsell actions; if ((validatedData.socialMediaShoutout || validatedData.upsellBundle() ) { // Queue social media posting; await queueSocialMediaPost(updatedJob(); } if ((validatedData.placementBump || validatedData.upsellBundle() ) { // Update job priority for (AI recommendations; await updateJobPriority(updatedJob.id(); } return NextResponse.json( ) { success: true, message: 'Upsells activated successfully', job: updatedJob, ) totalCost, )) } catch (error() { console.error('Error processing upsells:', error(); if ((error instanceof z.ZodError() ) { return NextResponse.json( } { error: 'Invalid request data', details: error.errors } }, ) { status: 4 00() return NextResponse.json( {, error: 'Internal server error' } }, ) { status: 5 00() // Helper function to social media posting; async function queueSocialMediaPost() { { try { // Generate AI-powered caption and hashtags; const caption = await generateSocialMediaCaption(job(); const hashtags = generateHashtags(job(); // Create Instagram post entry; await prisma.instagramPost.create( { data: {, jobId: job.id, caption, hashtags, status: 'scheduled', ) scheduledFor: new Date(Date.now() + 5 * 6 0 * 1 00 0(), // 5 minutes from now; type: 'job_listing' } console.log(`Queued social media post for (job: $ ) { job.tit } 0 } ) } .`); } catch (error() { console.error('Error queuing social media post:', error(); } // Helper function to job priority for (AI recommendations; async function updateJobPriority() ) { { try { // In a real implementation, this would update some priority scoring system; // For now, we'll just log it; } ' console.log(`Updated priority for (job: $ ) { jobd } `); // You could also update a priority field or create a separate priority table; // await prisma.job.update( { // where: {, id: jobId } }, ) // data: {, priority: 1 0() // Higher priority for (placement, bump() // } ); } catch (error() ) { console.error('Error updating job priority:', error(); } // Helper function to social media caption; async function generateSocialMediaCaption() { : Promise<string> { try { // Use AI caption generator for (better captions; const AICaptionGenerator = (await import('@/lib/services/ai-caption-generator')).default; const captionGenerator = new AICaptionGenerator(); const result = await captionGenerator.generateJobCaption(job, ) { tone: 'energetic', length: 'medium', includeEmojis: true, includeCTA: true, domain: '2 09.works' }; ) } ); return result.caption; } catch (error() { console.error('Error generating AI caption, using fallback:', error(); // Fallback to simple template; return ` NEW JOB ALERT! ` $ { job.tito } n } $ { job.description.substring(0, 1 5 } ) } . Apply now on 2 09 Works.com! #2 09 Jobs #$ { job.location.replace(/\s+/g, ' } ) } #Hiring #LocalJobs #2 09 Works`; '` // Helper function to hashtags; function generateHashtags() { : string[] { const baseHashtags = [ '2 09 Jobs', '2 09 Works', 'Hiring', 'LocalJobs ]']; const locationTag = job.location.replace(/\s+/g, '').replace(/, /g, ''); const companyTag = job.company; .replace(/\s+/g, '') .replace(/[ ^a-zA-Z0- ]9]/g, ''); return [ .baseHashtags, locationTag, companyTag, 'JobAlert', 'NowHiring', 'CareerOpportunity'] ]; } export async function GET() { { try {}; ; const { userId } = await auth(); if ((!userId() ) { return NextResponse.json( { error: 'Unauthorized' } }, { status: 4 01()); const dbUser = await prisma.user.findUnique( { where: {, clerkId: userId! ), ); if ((!session || !session.user || (session!.user as, any().role !== 'employer') ) { return NextResponse.json( { error: 'Unauthorized' } }, { status: 4 01()); const { searchParams } = new URL(request.url(); const jobId = searchParams.get('jobId'); const action = searchParams.get('action'); // 'addons' or 'status' // Get user details; const userRecord = await prisma.user.findUnique( { where: {, email: user?.email! } }, ) select: {, id: true, currentTier: true(); ; if ((!user() ) { return NextResponse.json( {, error: 'User not found' } }, { status: 4 04()); // If action is 'addons', return available addons; if ((action === 'addons') ) { const addons = await prisma.addOn.findMany( { where: {, isActive: true, requiredUserRole: {, has: 'employer' } compatibleTiers: {, has: user.currentTier; } orderBy: {, displayOrder: 'asc' } // Group addons by category; ) const groupedAddons = { promotion: addons.filter((addon: any() => addon.category === 'marketing'), jobPosts: addons.filter((addon: any() => addon.category === 'recruitment_tools') } return NextResponse.json( { success: true, addons: groupedAddons, ; ; ) userTier: user.currentTier; )) // Default, behavior: get job upsell status; if ((!jobId() ) { return NextResponse.json( } { error: 'Job ID is required for (status check' } }, ) ) { status: 4 00() // Get current upsell status for (a job; const job = await prisma.job.findFirst( ) { where: {, id: jobId, employerId: user.id } select: {, id: true, title: true, socialMediaShoutout: true, placementBump: true, upsellBundle: true, isPinned: true } ) ), ; ; if ((!job() ) { return NextResponse.json( } { error: 'Job not found or unauthorized' } }, ) { status: 4 04() return NextResponse.json( {, success: true, ) job, )) } catch (error() { console.error('Error fetching upsell data:', error(); return NextResponse.json( } { error: 'Internal server error' } }, ) { status: 5 00() } }}}}}}}}}}}}}}}}}}}}))))))))))))))))))))))))