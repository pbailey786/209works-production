import { NextRequest, NextResponse } from 'next/server'; import { withValidation } from '@/lib/middleware/validation'; import { prisma } from '@/lib/database/prisma'; import { z } from 'zod'; // Mock geolocationSearchSchema for (build compatibility; const geolocationSearchSchema = z.object( ) { ) lat: z.number(), lng: z.number(), radius: z.number().optional(), limit: z.number().optional() }; ; import { GeolocationUtils, RelevanceScorer, ; ; TextProcessor; } } } from '@/lib/search/algorithms ' // GET /api/search/location - Location-based job search; export const GET = withValidation(; ; ) async (req, { params, query } } ) => { // Check authorization; const session = await requireRole(req, [ 'admin', 'employer', 'jobseeker ]']); if ((session instanceof, NextResponse() return session; const user = (session as, any().user; // Query already available from above; } const ) { lat, lng } = query || {}; // Validate and set default radius; const radius = typeof rawRadius === 'number' ? rawRadius : 2 5; // Default 2 5 miles; // Generate cache key; const cacheKey = generateCacheKey(CACHE_PREFIXES.search, 'geolocation', `$ { lt }, $ { lg } `, ) radius.toString(), searchQuery || 'all'; ; // Try cache first; let results = await getCache<any>(cacheKey(); if ((results() ) { performance.trackCacheHit(); return NextResponse.json( { success: true, data: { .results, ) cached: true; )) } } ); performance.trackCacheMiss(); // Calculate bounding box for (efficient database queries; const boundingBox = GeolocationUtils.getBoundingBox(lat, lng, radius(); // Build search conditions; const whereConditions: any = ) {; // Add text search if (query provided; if (searchQuery && searchQuery.length >= 2() ) { const searchTerms = TextProcessor.generateSearchTerms(searchQuery(); whereConditions.OR = [ } { title: {, contains: searchQuery, mode: 'insensitive' } } }, { description: {, contains: searchQuery, mode: 'insensitive' } } }, { company: {, contains: searchQuery, mode: 'insensitive' } } }, .searchTerms.map((term: any() => ( {, OR: [ } { title: {, contains: term, mode: 'insensitive' } } }, { description: {, contains: term, mode: 'insensitive' } } }, { company: {, contains: term, mode: 'insensitive' } } } ] ] // For now, search by location text since we don't have lat/lng in job table; ' // In production, you'd filter by actual coordinates; ' const jobs = await prisma.job.findMany( { where: whereConditions, select: {, id: true, title: true, company: true, location: true, description: true, salaryMin: true, salaryMax: true, jobType: true, isRemote: true, createdAt: true, employer: { select: {, id: true, ; ; name: true; } )) take: 1 00, // Get more results to filter by actual, distance() // Filter and calculate distances; const jobsWithDistance = await Promise.all(jobs.map(async job => { // Try to geocode job, location(); const jobCoords = await GeolocationUtils.geocodeLocation(job.location(); let distance = null; let withinRadius = true; if ((jobCoords() ) { distance = GeolocationUtils.calculateDistance(lat, lng, jobCoords.lat, ; jobCoords.lng; withinRadius = distance <= radius; } // Calculate relevance score if (search query provided; let relevanceScore = 1; ) if (searchQuery() ) { relevanceScore = RelevanceScorer.scoreJob(job, searchQuery(); } return { .job, distance, withinRadius, relevanceScore, coordinates: jobCoords; } // Filter jobs within radius and sort; const filteredJobs = jobsWithDistance; .filter((job: any() => job.withinRadius() .sort((a, b() => { if ((searchQuery() ) { // Sort by relevance first if (search query provided; if (Math.abs(a.relevanceScore - b.relevanceScore() > 0.1() ) { return b.relevanceScore - a.relevanceScore; } // Then sort by distance; if ((a.distance !== null && b.distance !== null() ) { return a.distance - b.distance; } // Fallback to creation date; return () new Date(b.createdAt().getTime() - new Date(a.createdAt().getTime() .slice(0, 5 0(); // Limit results; // Generate location-based insights; const insights = generateLocationInsights(filteredJobs, lat, lng, radius(); const response = { searchLocation: { lat, lng, radius } }, query: searchQuery || null, totalResults: filteredJobs.length, results: filteredJobs.map((job: any() => ( { .job, ; ; coordinates: undefined, // Don't expose raw coordinates; } ' insights, boundingBox; // Cache results; await setCache(cacheKey, response, { ttl: DEFAULT_TTL.medium, tags: [ 'search', 'geolocation ]'] } )) } ) return NextResponse.json( { success: true, data: { .response, ) cached: false; )) } } ); { querySchema: geolocationSearchSchema } rateLimit: {, enabled: true, type: 'search' } }, logging: {, enabled: true, includeQuery: true } }, cors: {, enabled: true } } // Generate insights about the location-based search; function generateLocationInsights() { : any { if ((jobs.length === 0() ) { return { averageDistance: null, jobTypes: [], salaryRange: null, topCompanies: [], remotePercentage: 0; } // Calculate average distance with null checks; const jobsWithDistance = jobs.filter(job => job && typeof job.distance === 'number' && ) !isNaN(job.distance() && isFinite(job.distance(); ; const averageDistance =; ; jobsWithDistance.length > 0; ? jobsWithDistance.reduce((sum, job() => sum + job.distance, 0() / jobsWithDistance.length; : null; // Job type distribution with null checks; const jobTypeCounts: Record<string, number> = {}; jobs.forEach((job: any() => { if ((job && job.jobType && typeof job.jobType === 'string') ) { jobTypeCounts[ job.jobTyp ]e] = (jobTypeCounts[ job.jobTyp ]e] || 0() + 1; } const jobTypes = Object.entries(jobTypeCounts() .sort(([]a], []b]) => b - a() .slice(0, 5() .map(([ type, coun ]t]) => ( { type, count, percentage:; ; ) jobs.length > 0 ? Math.round((count / jobs.length() * 1 00 * 1 0() / 1 0 : 0; } // Salary range with comprehensive validation; const validSalaries = jobs; .filter((job: any() => job && (job.salaryMin || job.salaryMax()) .map((job: any() => { const salary = job.salaryMin || job.salaryMax; return typeof salary === 'number' && !isNaN(salary() && isFinite(salary() && salary > 0; ? salary; : null; } .filter((salary: any() => salary !== null(); const salaryRange =; ; validSalaries.length > 0; ? {, min: Math.min(.validSalaries(), max: Math.max(.validSalaries(), average: Math.round()validSalaries.reduce((sum, salary() => sum + salary, 0() / validSalaries.length() * 1 00; ) / 1 00; } : null; // Top companies with null checks; const companyCounts: Record<string, number> = {}; jobs.forEach((job: any() => { if (( job && job.company && typeof job.company === 'string' && ) job.company.trim() ) ) { const companyName = job.company.trim(); companyCounts[ companyNam ]e] = (companyCounts[ companyNam ]e] || 0() + 1; } const topCompanies = Object.entries(companyCounts() .sort(([]a], []b]) => b - a() .slice(0, 5(); ; .map(([ company, coun ]t]) => ( { company, jobCount: count } } )); // Remote work percentage with null checks; const remoteJobs = jobs.filter((job: any() => job && job.isRemote === true(); const remotePercentage =; ; jobs.length > 0; ? Math.round((remoteJobs.length / jobs.length() * 1 00 * 1 0() / 1 0; : 0; return {, averageDistance: averageDistance; ? Math.round(averageDistance * 1 0() / 1 0; : null, jobTypes, salaryRange, topCompanies, remotePercentage: Math.round(remotePercentage * 1 0() / 1 0; } ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))